\chapter{Машини на Тюринг}

\setlength{\epigraphwidth}{0.65\textwidth}\epigraph{Turing’s ‘Machines’. These machines are humans who calculate. \cite[§ 1096]{rpp1}.}




% \begin{framed}
%   {\bf Теза на Чърч-Тюринг:} Всеки алгоритъм може да се осъществи като машина на Тюринг.
% \end{framed}

\input{turing/intro}

\input{turing/examples}

\input{turing/multitape}

\input{turing/functions}

\newpage
\input{turing/nondeterministic}


\input{turing/properties}

% \section{Машини на Тюринг като генератори}

% \mynote{\cite[стр. 168]{hopcroft1}}
% \mynote{\cite[стр. 180]{sipser3}}
% \mynote{На англ. се наричат {\em enumerators}}

% Нека да разгледаме един вариант на многолентовите машини на Тюринг, които ще наричаме {\bf генератори}.
% Нека машината на Тюринг да има две ленти, като в началото и двете ленти са празни.
% \begin{itemize}
% \item 
%   Първата лента ще служи за работна лента - върху нея можем да пишем и четем;
% \item
%   Втората лента служи единствено за изход - върху нея можем само да пишем пишем думи; не можем да четем какво вече сме написали върху нея и не можем да пишем върху вече записана клетка. Думите са разделени със специален символ - $\#$.
%   Това означава, че втората лента има вида
%   \[\omega_1\#\omega_2\#\cdots\#\omega_n\#\blank\blank\cdots\]
% \item
%   Езикът, които се извежда от такъв генератор е съставен от думите, които са изписани на изходната лента.
%   Такива езици ще наричаме {\bf изчислимо изброими}.
%   Обърнете внимание, че измежду думите на изходната лента е възможно да има повторения.
%   Ако езикът е безкраен, то машината ще работи безкрайно много време.
% \end{itemize}

% \begin{framed}
%   \begin{thm}
%     Един език $L$ е полуразрешим точно тогава, когато $L$ е изчислимо номеруем.
%   \end{thm}
% \end{framed}
% \begin{proof}
%   $(\Leftarrow)$ Нека $L$ да се номерира от генераторът $E$.
%   Машината на Тюринг $\M$, за която $L = \L(\M)$ ще работи по следния начин:
%   \begin{enumerate}[1)]
%   \item 
%     При вход думата $\omega$, $\M$ започва да симулира $E$;
%   \item
%     Когато се появи дума $\gamma$ върху изходната лента на $E$, сравняваме $\omega$ с $\gamma$;
%   \item
%     Ако $\omega = \gamma$, то отиваме в състоянието $q_{accept}$ на $\M$ и завършваме;
%   \item
%     В противен случай, отиваме обратно на стъпка $2)$.
%   \end{enumerate}

%   $(\Rightarrow)$ Нека сега $L = \L(\M)$. Целта ни е да изведем всички думи на $L$ върху изходната лента.
%   Основният проблем е, че за дадена дума $\omega$, не знаем за колко стъпки трябва да симулираме $\M$ за да сме сигурни дали думата $\omega \in \L(\M)$ или не. Оказва се, че можем да разрешим този проблем като позволяме да извеждаме повторящи се думи.
%   За целта, да подредим всички думи $\omega_1, \omega_2, \dots $ над азбуката $\Sigma$ спрямо каноничната наредба.
%   \begin{enumerate}[1)]
%   \item
%     Нека $s = 1$;
%   \item 
%     Симулираме $\M$ върху думите $\omega_1,\dots,\omega_s$ за $s$ стъпки;
%   \item
%     За всяка от тези думи $\omega_i$, които се приемат от $\M$, записваме ги върху изходната лента.
%   \item
%     Нека $s = s+1$; Отиваме обратно на стъпка $2)$.
%   \end{enumerate}
% \end{proof}

% \begin{remark}
%   В последната конструкция позволяваме думите на един полуразрешим език $L$ да се 
%   извеждат върху изходната лента многократно. Можем лесно да осигурим условието всяка дума на $L$
%   да се извежда точно по веднъж.
%   На стъпка $s = \pair{i,j}$, то проверяваме дали думата $\omega_i$ се приема успешно от $\M$
%   за {\em точно} $j$ на брой стъпки. Само тогава думата се записва на изходната лента.
  
%   Обърнете внимание, че не можем да осигурим условието думите да се извеждат във възходящ ред
%   относно каноничната наредба.
% \end{remark}

% \begin{framed}
%   \begin{thm}
%     Един език $L$ е разрешим точно тогава, когато съществува генератор за $L$, 
%     който изписва думите на $L$ във възходящ ред относно каноничната наредба.
%   \end{thm}
% \end{framed}
% \begin{proof}
%   $(\Rightarrow)$ Нека $L = \L(\M)$. Тази посока е лесна, защото $\M$ е тотална машина,
%   т.е. за всеки вход $\M$ завършва или в $q_{accept}$ или в $q_{reject}$.
%   \begin{enumerate}[1)]
%   \item 
%     Нека $s = 1$;
%   \item
%     Симулираме $\M$ върху думата $\omega_s$.
%   \item
%     Ако симулацията завърши в състояние $q_{accept}$, то записваме $\omega_s$
%     върху изходната лента. 
%   \item
%     Иначе ако симулацията завърши в състояние $q_{reject}$, то нищо не записваме върху изходната лента. 
%   \item
%     Нека $s = s+1$. Отиваме на стъпка $2)$.
%   \end{enumerate}

%   \mynote{Ако имам генератор $G$ за $L$ няма алгоритъм, който да ми каже дали $L$ е безкраен език или не. Това означава, че по код на $G$ няма как ефективно да получа код на $\M$}
%   $(\Leftarrow)$ Ако $L$ е краен, то е ясно, че мога да разпозная езика с краен автомат, което е частен случай на тотална машина на Тюринг.
%   По-интересният случай е когато $L$ е безкраен език.
%   Нека $L$ се генерира от машината на Тюринг $G$ като извежда думите на $L$ във възходящ ред.
%   \begin{itemize}
%   \item 
%     Вход дума $\omega$;
%   \item
%     Симулираме $G$ като гледаме думите, които се извеждат на изходната лента.
%     Ако срещнем думата $\omega$, то завършваме в състояние $q_{accept}$.
%   \item
%     Ако срещнем думата $\gamma$, която е по-голяма от $\omega$ относно каноничната наредба, 
%     то завършваме в състояние $q_{reject}$.
%   \end{itemize}
% \end{proof}

\input{turing/coding}

\input{turing/diagonal}

\input{turing/universal}

\input{turing/rice}

\input{turing/rice-shapiro}

% \input{turing/computations}
% \input{turing/greibach}
% \newpage
% \input{turing/grammar}

% \input{turing/context-sensitive}

\input{turing/complexity}

\input{turing/problems}

% \input{turing/restrictions}

% \input{turing/lba}

% \input{turing/pcp}

% \section*{Бележки}

% \begin{itemize}
% \item
%   За основните дефиниции следваме основно Глава 3 от \cite{sipser3}.
% \item 
%   За въпросите за неразрешимост следваме основно Глава 8 от \cite{hopcroft1}.
% % \item
% %   За по-задълбочено запознаване с теория на изчислимостта, добри уводни книги са
% %   \cite{ditchev-soskov} и \cite{nikolova-soskova}.
% \end{itemize}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../eai"
%%% End:
