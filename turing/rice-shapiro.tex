\section{Критерии за полуразрешимост}

\begin{lemma}
  Нека $\Ss$ е свойство на полуразрешимите езици.
  Ако съществува безкраен език $L_0 \in \Ss$, който няма крайно подмножество в $\Ss$,
  то $L_\Ss$ не е полуразрешим език.  
\end{lemma}
\begin{hint}
  Нека $L_0 = \L(\M_0)$.
  Ще опишем алгоритъм, който при вход дума $\code{\M}\cdot\omega$,
  извежда код на машина на Тюринг $\M'_\omega$, която работи така:
  \begin{itemize}
  \item 
    вход думата $\alpha$;
  \item
    $\M'_\omega$ симулира $\M$ върху думата $\omega$:
    \begin{itemize}
    \item 
      ако $\M$ завърши за по-малко от $|\alpha|$ на брой стъпки като {\em отхвърли} $\omega$, 
      то $\M'_\omega$ симулира $\M_0$ върху $\alpha$;
    \item 
      ако $\M$ завърши за по-малко от $|\alpha|$ на брой стъпки като приеме $\omega$, 
      то $\M'_\omega$ завършва като отхвърля $\alpha$.
    \item
      ако $\M$ не завърши за по-малко от $|\alpha|$ на брой стъпки върху $\omega$,
      то $\M'_\omega$ завършва като отхвърля $\alpha$.
    \end{itemize}
  \end{itemize}

  Така получаваме, че 
  \begin{align*}
    \L(\M') = 
    \begin{cases}
      \{\alpha \in L_0 \mid \abs{\alpha} < s\}, & \text{ако } \M\text{ приема }\omega\\
      L, & \text{ако }\M\text{ не приема }\omega,
    \end{cases}
  \end{align*}
  където $s$ е минималното число, такова че 
  $\M$ завършва за $s$ на брой стъпки като приема думата $\omega$.
  
  Заключаваме, че 
  \begin{align*}
    & \code{\M}\cdot \omega \in L_{\texttt{univ}} \implies \code{\M'_\omega} \not\in L_\Ss\\
    & \code{\M}\cdot \omega \not\in L_{\texttt{univ}} \implies \code{\M'_\omega} \in L_\Ss.
  \end{align*}
  % \[\code{\M}\cdot \omega \not\in L_{\texttt{univ}} \iff \code{\M'} \in L_\Ss.\]
  Това означава, че ефективно можем да сведем въпрос за принадлежност в $\ov{L}_{\texttt{univ}}$
  към въпрос за принадлежност в $L_\Ss$.
  Следователно, ако $L_\Ss$ е полуразрешим език, то $\ov{L}_{\texttt{univ}}$ е полуразрешим език, което е противоречие.
\end{hint}

\begin{cor}
  Следните езици {\bf не} са полуразрешими:
  \begin{itemize}
  \item 
    $L = \{\code{\M} \mid \abs{\L(\M)} = \infty\}$;
  \item
    $L = \{\code{\M} \mid \L(\M) = \Sigma^\star\}$;
  \item
    $L = \{\code{\M} \mid \L(\M)\text{ не е разрешим}\}$;
  \item
    $L = \{\code{\M} \mid \L(\M)\text{ не е полуразрешим}\}$;
  \item
    $L = \{\code{\M} \mid \L(\M)\text{ не е регулярен}\}$.
  \end{itemize}
\end{cor}

\begin{lemma}
  Нека $L_1$ е език в $\Ss$ и нека $L_2$ е полуразрешим език, като $L_1 \subset L_2$ и $L_2 \not\in\Ss$.
  Тогава $L_\Ss$ не е полуразрешим език.
\end{lemma}
\begin{hint}
  Нека $L_1 = \L(\M_1)$ и $L_2 = \L(\M_2)$.
  Ще опишем алгоритъм, който при вход дума $\code{\M}\cdot\omega$,
  извежда код на машина на Тюринг $\M'$, която работи така:
  \begin{itemize}
  \item 
    вход думата $\alpha$;
  \item
    $\M'_\omega$ симулира едновременно две изчисления - $\M_1$ върху $\alpha$ и $\M$ върху $\omega$
    докато намери стъпка $s$, такава че:    
    \begin{itemize}
    \item 
      ако $\M_1$ завършва за $s$ на брой стъпки като приема думата $\alpha$, то $\M'_\omega$ завършва като приеме думата $\alpha$;
    \item
      ако $\M$ за завършва за $s$ на брой стъпки като приема думата $\omega$, 
      то $\M'_\omega$ започваме да симулира $\M_2$ върху $\alpha$;
      \begin{itemize}
      \item 
        Ако $\M_2$ завърши като приеме $\alpha$, то $\M'_\omega$ завършва като приема $\alpha$;
      \item 
        Ако $\M_2$ завърши като отхвърли $\alpha$, то $\M'_\omega$ завършва като отхвърля $\alpha$;
      \item 
        Ако $\M_2$ не завършва никога върху $\alpha$, то $\M'_\omega$ никога не завършва върху $\alpha$.
      \end{itemize}
    \item
      ако $\M'_\omega$ не намери такава стъпка, то $\M'_\omega$ никога не завършва върху $\alpha$.
    \end{itemize}
  \end{itemize}
  
  Получаваме, че:
  \begin{align*}
    \L(\M'_\omega) = 
    \begin{cases}
      L_2, & \text{ако $\M$ приема }\omega\\
      L_1, & \text{ако $\M$ не приема }\omega.
    \end{cases}
  \end{align*}
  Заключаваме, че:
  \[\code{\M}\cdot\omega \in \ov{L}_{\texttt{univ}} \iff \code{\M'_\omega} \in L_\Ss,\]
  защото $L_2 \not\in \Ss$, а $L_1 \in \Ss$.
  Това означава, че ефективно можем да сведем въпрос за принадлежност в $\ov{L}_{\texttt{univ}}$
  към въпрос за принадлежност в $L_\Ss$.
  Следователно, ако $L_\Ss$ е полуразрешим език, то $\ov{L}_{\texttt{univ}}$ е полуразрешим език, което е противоречие.  
\end{hint}

\begin{cor}
  Следните езици {\bf не} са полуразрешими:
  \begin{itemize}
  \item 
    $L = \{\code{\M} \mid \L(\M) \text{ е регулярен} \}$;
  \item
    $L = \{\code{\M} \mid \L(\M) \text{ е безконтекстен} \}$;
  \item
    $L = \{\code{\M} \mid \L(\M) \text{ е разрешим} \}$;
  \item
    $L = \{\code{\M} \mid \abs{\L(\M)} = 42\}$;
  \end{itemize}
\end{cor}


% % \section{Проблеми за безконтекстни езици}

% % \begin{lemma}
% %   Нека е дадена $\M = \TM$.
% %   Тогава езикът 
% %   \[L = \{\alpha\sharp\beta^R \mid \alpha,\beta \in \Gamma^\star Q \Gamma^\star\ \&\  \alpha \vdash_\M \beta\}\]
% %   е безконтекстен.
% % \end{lemma}
% % \begin{proof}
% %   Ще покажем, че съществува стеков автомат $P$, за който $\L_S(P) = L$.
% %   Четем буквата $X$. Тогава:
% %   \begin{itemize}
% %   \item 
% %     ако $\delta_\M(q,X) =(p,Y,R)$, то слагаме $Yp$ на върха на стека;
% %   \item
% %     ако $\delta_\M(q,X) =(p,Y,L)$, то ако $Z$ е върха на стека, заменяме $Z$ с $pZY$;
% %   \end{itemize}
% % \end{proof}



% % \begin{thm}
% %   Неразрешим е проблемът за проверка дали при дадени две произволни безконтекстни граматики $G_1$ и $G_2$,
% %   $\L(G_1) \cap \L(G_2) = \emptyset$.  
% % \end{thm}

% % \begin{thm}
% %   Неразрешим е проблемът за проверка дали при дадена произволна безконтекстна граматика $G$,
% %   $\L(G) = \Sigma^\star$.  
% % \end{thm}


% % \section{Въпроси}

% % Вярно ли е, че следният проблем е {\em разрешим}:
% % \begin{itemize}
% % \item
% %   за произволна безконтекстна граматика $G$, проверява дали $\L(G) = \emptyset$?
% % \item
% %   за произволна безконтекстна граматика $G$, проверява дали $\L(G) = \Sigma^\star$?
% % \item
% %   за произволни безконтекстни граматики $G_1$ и $G_2$, проверява дали $\L(G_1) \cap \L(G_2) = \emptyset$?
% % \item
% %   за произволни безконтекстни граматики $G_1$ и $G_2$, проверява дали $\L(G_1) \cap \L(G_2) = \Sigma^\star$?
% % \item
% %   за произволни безконтекстни граматики $G_1$ и $G_2$, проверява дали $\L(G_1) = \L(G_2)$?
% % \item
% %   за произволни безконтекстни граматики $G_1$ и $G_2$, проверява дали $\L(G_1) \subseteq \L(G_2)$?
% % \item
% %   за произволна безконтекстна граматика $G$ и произволен регулярен израз $r$,
% %   проверява дали $\L(G) = \L(r)$?
% % \item
% %   за произволна безконтекстна граматика $G$ и произволен регулярен израз $r$,
% %   проверява дали $\L(G) \subseteq \L(r)$?
% % \item
% %   за произволна безконтекстна граматика $G$ и произволен регулярен израз $r$,
% %   проверява дали $\L(r) \subseteq \L(G)$?
% % \item
% %   за произволни безконтекстни граматики $G_1$ и $G_2$, проверява дали $\L(G_1) \subseteq \L(G_2)$ 
% %   е безконтекстен език ?
% % \item
% %   за произволна безконтекстна граматика $G$, проверява дали $\Sigma^\star \setminus \L(G)$
% %   е безконтекстен език ?
% % \item
% %   за произволна безконтекстна граматика $G$, проверява дали $\L(G)$ е регулярен език?
% % \end{itemize}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../eai"
%%% End:
