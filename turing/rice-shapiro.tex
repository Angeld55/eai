\section{Критерии за полуразрешимост}

\begin{lemma}
  \mynote{Това означава, че ако $\texttt{Code}(\Ss)$ е полуразрешим език, то ако $L_0 \in \Ss$, всеки краен подезик на $L_0$ също принадлежи на $\Ss$.}
  Нека $\Ss$ е свойство на полуразрешимите езици.
  Ако съществува безкраен език $L_0 \in \Ss$, който няма крайно подмножество в $\Ss$,
  то $\texttt{Code}(\Ss)$ не е полуразрешим език.  
\end{lemma}
\begin{hint}
  Нека $L_0 = \L(\M_0)$ като $L_0 \in \Ss$, но всеки краен подезик на $L_0$ не принадлежи на $\Ss$.
  Ще опишем алгоритъм, който при вход дума $\code{\M}$,
  извежда код на машина на Тюринг $\M'$, която работи така:
  \begin{itemize}
  \item 
    вход думата $\alpha$;
  \item
    $\M'$ симулира $\M$ върху думата $\code{\M}$:
    \begin{itemize}
    \item 
      ако $\M$ завърши за по-малко от $|\alpha|$ на брой стъпки като {\em отхвърли} $\code{\M}$, 
      то $\M'$ симулира $\M_0$ върху $\alpha$;
    \item 
      ако $\M$ завърши за по-малко от $|\alpha|$ на брой стъпки като приеме $\code{\M}$, 
      то $\M'$ завършва като {\em отхвърля} $\alpha$;
    \item
      ако $\M$ не завърши за по-малко от $|\alpha|$ на брой стъпки върху $\code{\M}$,
      то $\M'$ симулира $\M_0$ върху $\alpha$.
    \end{itemize}
  \end{itemize}
  Така получаваме, че 
  \begin{align*}
    \L(\M') = 
    \begin{cases}
      \{\alpha \in L_0 \mid \abs{\alpha} < s_0\}, & \text{ако } \M\text{ приема }\code{\M}\\
      L_0, & \text{ако }\M\text{ не приема }\code{\M},
    \end{cases}
  \end{align*}
  където $s_0$ е минималният брой стъпки необходими на $\M$ за да приеме думата $\code{\M}$.
  
  Заключаваме, че 
  \begin{align*}
    & \M \text{ не приема }\code{\M} \implies \code{\M} \in L_{\texttt{diag}} \implies \code{\M'} \in \texttt{Code}(\Ss)\\
    & \M \text{ приема }\code{\M} \implies \code{\M} \not\in L_{\texttt{diag}} \implies \code{\M'} \not\in \texttt{Code}(\Ss).
  \end{align*}
  Това означава, че ефективно можем да сведем въпрос за принадлежност в $L_{\texttt{diag}}$
  към въпрос за принадлежност в $\texttt{Code}(\Ss)$.
  Следователно, ако $\texttt{Code}(\Ss)$ е полуразрешим език, то $L_{\texttt{diag}}$ е полуразрешим език, което е противоречие.
\end{hint}

\begin{cor}
  Следните езици {\bf не} са полуразрешими:
  \begin{itemize}
  \item 
    $L = \{\code{\M} \mid \abs{\L(\M)} = \infty\}$;
  \item
    $L = \{\code{\M} \mid \L(\M) = \Sigma^\star\}$;
  \item
    $L = \{\code{\M} \mid \L(\M)\text{ не е разрешим}\}$;
  \item
    $L = \{\code{\M} \mid \L(\M)\text{ не е полуразрешим}\}$;
  \item
    $L = \{\code{\M} \mid \L(\M)\text{ не е регулярен}\}$.
  \end{itemize}
\end{cor}

\begin{lemma}
  \mynote{Това означава, че ако $\texttt{Code}(\Ss)$ е полуразрешим език, ако $L_0 \in \Ss$ и $L_0 \subseteq L_1$, като $L_1$ е полуразрешим, то $L_1 \in \Ss$.}
  Нека $L_1$ е език в $\Ss$ и нека $L_2$ е полуразрешим език, като $L_1 \subset L_2$ и $L_2 \not\in\Ss$.
  Тогава $\texttt{Code}(\Ss)$ не е полуразрешим език.
\end{lemma}
\begin{hint}
  Нека $L_1 = \L(\M_1)$ и $L_2 = \L(\M_2)$.
  Ще опишем алгоритъм, който при вход дума $\code{\M}$,
  извежда код на машина на Тюринг $\M'$, която работи така:
  \begin{itemize}
  \item 
    вход думата $\alpha$;
  \item
    $\M'$ симулира едновременно две изчисления - $\M_1$ върху $\alpha$ и $\M$ върху $\code{\M}$
    докато намери стъпка $s$, такава че:    
    \begin{itemize}
    \item 
      ако $\M_1$ завършва за $s$ на брой стъпки като приема думата $\alpha$, то $\M'$ завършва като приема думата $\alpha$;
    \item
      ако $\M$ завършва за $s$ на брой стъпки като приема думата $\code{\M}$, 
      то $\M'$ започва да симулира $\M_2$ върху $\alpha$;
      \begin{itemize}
      \item 
        Ако $\M_2$ завърши като приеме $\alpha$, то $\M'$ завършва като приема $\alpha$;
      \item 
        Ако $\M_2$ завърши като отхвърли $\alpha$, то $\M'$ завършва като отхвърля $\alpha$;
      \item 
        Ако $\M_2$ не завършва никога върху $\alpha$, то $\M'$ никога не завършва върху $\alpha$.
      \end{itemize}
    \item
      ако $\M'$ не намери такава стъпка, то $\M'$ никога не завършва върху $\alpha$.
    \end{itemize}
  \end{itemize}
  Получаваме, че:
  \begin{align*}
    \L(\M') = 
    \begin{cases}
      L_2, & \text{ако $\M$ приема }\code{\M}\\
      L_1, & \text{ако $\M$ не приема }\code{\M}.
    \end{cases}
  \end{align*}
  Заключаваме, че:
  \[\code{\M} \in L_{\texttt{diag}} \iff \code{\M'} \in \texttt{Code}(\Ss),\]
  защото $L_2 \not\in \Ss$, а $L_1 \in \Ss$.
  Това означава, че ефективно можем да сведем въпрос за принадлежност в $L_{\texttt{diag}}$
  към въпрос за принадлежност в $\texttt{Code}(\Ss)$.
  Следователно, ако $\texttt{Code}(\Ss)$ е полуразрешим език, то $L_{\texttt{diag}}$ е полуразрешим език, което е противоречие.  
\end{hint}

\begin{cor}
  Следните езици {\bf не} са полуразрешими:
  \begin{itemize}
  \item 
    $L = \{\code{\M} \mid \L(\M) \text{ е регулярен} \}$;
  \item
    $L = \{\code{\M} \mid \L(\M) \text{ е безконтекстен} \}$;
  \item
    $L = \{\code{\M} \mid \L(\M) \text{ е разрешим} \}$;
  \item
    $L = \{\code{\M} \mid \abs{\L(\M)} = 42\}$.
  \end{itemize}
\end{cor}


\begin{framed}
  \begin{theorem}[Райс-Шапиро]
    Нека $\texttt{Code}(\Ss)$ е полуразрешим език. Тогава е изпълнено, че:
    \[L \in \Ss \iff (\forall L_0 \subseteq \Sigma^\star )[L_0\text{ е краен и }L_0 \subseteq L \implies L_0 \in \Ss].\]
  \end{theorem}
\end{framed}


% % \section{Проблеми за безконтекстни езици}

% % \begin{lemma}
% %   Нека е дадена $\M = \TM$.
% %   Тогава езикът 
% %   \[L = \{\alpha\sharp\beta^R \mid \alpha,\beta \in \Gamma^\star Q \Gamma^\star\ \&\  \alpha \vdash_\M \beta\}\]
% %   е безконтекстен.
% % \end{lemma}
% % \begin{proof}
% %   Ще покажем, че съществува стеков автомат $P$, за който $\L_S(P) = L$.
% %   Четем буквата $X$. Тогава:
% %   \begin{itemize}
% %   \item 
% %     ако $\delta_\M(q,X) =(p,Y,R)$, то слагаме $Yp$ на върха на стека;
% %   \item
% %     ако $\delta_\M(q,X) =(p,Y,L)$, то ако $Z$ е върха на стека, заменяме $Z$ с $pZY$;
% %   \end{itemize}
% % \end{proof}



% % \begin{thm}
% %   Неразрешим е проблемът за проверка дали при дадени две произволни безконтекстни граматики $G_1$ и $G_2$,
% %   $\L(G_1) \cap \L(G_2) = \emptyset$.  
% % \end{thm}

% % \begin{thm}
% %   Неразрешим е проблемът за проверка дали при дадена произволна безконтекстна граматика $G$,
% %   $\L(G) = \Sigma^\star$.  
% % \end{thm}


% % \section{Въпроси}

% % Вярно ли е, че следният проблем е {\em разрешим}:
% % \begin{itemize}
% % \item
% %   за произволна безконтекстна граматика $G$, проверява дали $\L(G) = \emptyset$?
% % \item
% %   за произволна безконтекстна граматика $G$, проверява дали $\L(G) = \Sigma^\star$?
% % \item
% %   за произволни безконтекстни граматики $G_1$ и $G_2$, проверява дали $\L(G_1) \cap \L(G_2) = \emptyset$?
% % \item
% %   за произволни безконтекстни граматики $G_1$ и $G_2$, проверява дали $\L(G_1) \cap \L(G_2) = \Sigma^\star$?
% % \item
% %   за произволни безконтекстни граматики $G_1$ и $G_2$, проверява дали $\L(G_1) = \L(G_2)$?
% % \item
% %   за произволни безконтекстни граматики $G_1$ и $G_2$, проверява дали $\L(G_1) \subseteq \L(G_2)$?
% % \item
% %   за произволна безконтекстна граматика $G$ и произволен регулярен израз $r$,
% %   проверява дали $\L(G) = \L(r)$?
% % \item
% %   за произволна безконтекстна граматика $G$ и произволен регулярен израз $r$,
% %   проверява дали $\L(G) \subseteq \L(r)$?
% % \item
% %   за произволна безконтекстна граматика $G$ и произволен регулярен израз $r$,
% %   проверява дали $\L(r) \subseteq \L(G)$?
% % \item
% %   за произволни безконтекстни граматики $G_1$ и $G_2$, проверява дали $\L(G_1) \subseteq \L(G_2)$ 
% %   е безконтекстен език ?
% % \item
% %   за произволна безконтекстна граматика $G$, проверява дали $\Sigma^\star \setminus \L(G)$
% %   е безконтекстен език ?
% % \item
% %   за произволна безконтекстна граматика $G$, проверява дали $\L(G)$ е регулярен език?
% % \end{itemize}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../eai"
%%% End:
