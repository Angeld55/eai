\chapter{Регулярни езици и автомати}
\label{ch:regular}
\section{Автоматни езици}

% Един от източниците е втора и трета глава от книгата на Сипсер, \cite{sipser}.
% Друг основен източник е книгата на Пападимитриу и Люис, \cite{papadimitriou}.
%По Сипсер, стр. 35
\begin{dfn}
  Краен автомат е петорка $\A = \FA$, където
  \begin{enumerate}[1)]
  \item
    $Q$ е крайно множество от състояния;
  \item
    $\Sigma$ е азбука;
  \item
    % \marginpar{Тук нямаме $\varepsilon$-преходи}
    \marginpar{В \cite{sipser1} се разглеждат тотални $\delta$ функции}
    $\delta:Q\times\Sigma\to Q$ е (частична) функция на преходите;
  \item
    $s\in Q$ е начално състояние;
  \item
    $F\subseteq Q$ е множеството от финални състояния, $F \neq \emptyset$.
  \end{enumerate}
\end{dfn}

\index{автомат!детерминиран}\index{автомат!тотален детерминиран}
Ако функцията на преходите $\delta$ е тотална функция, то казваме, 
че автоматът $\A$ е {\bf тотален}. Това означава, че за всяка двойка $(a,q) \in \Sigma\times Q$,
същесествува $q' \in Q$, за което $\delta(a,q) = q'$.

Нека имаме една дума $\alpha \in \Sigma^\star$, $\alpha = a_1a_2\cdots a_n$.
Казваме, че $\alpha$ се {\bf разпознава} от автомата $\A$, ако
съществува редица от състояния $q_0,q_1,q_2,\dots,q_n$, такива че:
\begin{itemize}
\item
  $q_0 = s$, началното състояние на автомата;
\item
  $\delta(q_i,a_{i+1}) = q_{i+1}$, за всяко $i = 0, \dots, n-1$;
\item
  $q_n \in F$.
\end{itemize}

% Алтернативен запис е следния:
% $(q,a\beta) \vdash (p,\beta)$, ако $\delta(q,a) = p$.
% $(q,\alpha\beta) \vdash^\star (p,\beta)$, ако $\delta^\star(q,\alpha) = p$.
% Тогава една дума $\alpha$ се разпознава от автомата, ако $(s,\alpha) \vdash^\star (p,\varepsilon)$ и $p \in F$.

Казваме, че $\A$ {\bf разпознава} езика $L$, ако $\A$ разпознава точно думите от $L$, т.е.
$L = \{\alpha \in \Sigma^\star \mid \A\mbox{ разпознава }\alpha\}$.
Обикновено означаваме езика, който се разпознава от даден автомат $\A$ с $\L(\A)$.
\index{език!автоматен}
В такъв случай ще казваме, че езикът $L$ е {\bf автоматен}.

При дадена (частична) функция на преходите $\delta$,
често е удобно да разглеждаме (частичната) функция $\delta^\star:Q\times\Sigma^\star \to Q$, кято е дефинирана по следния начин:
\marginpar{Това е пример за индуктивна (рекурсивна) дефиниция по дължината на думата $\alpha$}
\begin{itemize}
\item 
  $\delta^\star(q,\varepsilon) = q$, за всяко $q\in Q$;
\item
  $\delta^\star(q,a\beta) = \delta^\star(\delta(q,a),\beta)$, за всяко $q\in Q$, всяко $a\in\Sigma$ и $\beta\in\Sigma^\star$.
\end{itemize}
Тогава една дума $\alpha$ се {\em разпознава} от автомата $\A$ точно тогава, когато $\delta^\star(s,\alpha) \in F$.
Оттук следва, че
\[\L(\A) = \{\alpha\in\Sigma^\star \mid \delta^\star(s,\alpha) \in F\}.\]

\begin{prop}
  $(\forall q\in Q)(\forall\alpha,\beta\in\Sigma^\star)[\delta^\star(q,\alpha\beta) = \delta^\star(\delta^\star(q,\alpha),\beta)]$.
\end{prop}
\begin{proof}
  \marginpar{\ding{45} Напише доказателството!}
  Индукция по дължината на $\alpha$.
\end{proof}

\index{моментно описание}
\marginpar{(На англ. {\em instantaneous description})}
{\em Моментното описание} на изчисление с краен автомат представлява двойка от вида $(q,\alpha) \in Q\times\Sigma^\star$,
т.е. автоматът се намира в състояние $q$, а думата, която остава да се прочете е $\alpha$.
Удобно е да въведем бинарната релация $\vdash_\A$ над $Q\times\Sigma^\star$,
която ще ни казва как моментното описание на автомата $\A$ се променя след изпълнение на една стъпка:
\[(q,x\alpha) \vdash_\A (p,\alpha), \text{ ако } \delta(q,x) = p.\]
\marginpar{Рефл. и транз. затваряне на една релация е разгледано в Глава \ref{ch:intro}}
Рефлексивното и транзитивно затваряне на $\vdash_\A$ ще означаваме с $\vdash^\star_\A$.
Получаваме, че 
\[\L(\A) = \{\alpha\in\Sigma^\star \mid (s,\alpha) \vdash^\star_\A(p,\varepsilon)\ \&\ p \in F\}.\]

Нашата дефиниция на автомат позволява $\delta$ да бъде частична функция, т.е.
може да има $q\in Q$ и $a\in\Sigma$, за които $\delta(q,a)$ не е дефинирана.
Следващото твърдение ни казва, че ние съвсем спокойно можем да разглеждаме автомати
само с тотални функции на преходите  $\delta$.
\begin{prop}
  За всеки краен автомат $\A$, съществува {\em тотален} краен автомат $\A'$,
  за който $\L(\A) = \L(\A')$.
\end{prop}
\begin{proof}
  Нека $\A = \FA$.
  Дефинираме тоталния автомат 
  \[\A' = \pair{Q\cup\{q_e\}, \Sigma, \delta', s, F},\]
  като за всеки преход $(q,a)$, за който $\delta$ не е дефинирана, 
  дефинираме $\delta'$ да отива в новото състояние $q_e$.
  Ето и цялата дефиниция на новата функция на преходите $\delta'$:
  \begin{itemize}
  \item 
    \marginpar{$q_e$ - error състояние}
    $\delta'(q_e,a) = q_e$, за всяко $a\in\Sigma$;
  \item
    \marginpar{$\A'$ симулира $\A$}
    За всяко $q\in Q$, $a\in\Sigma$, ако $\delta(q,a) = p$, то
    $\delta'(q,a) = p$;
  \item
    За всяко $q\in Q$, $a\in\Sigma$, ако $\delta(q,a)$ не е дефинирано, то
    $\delta'(q,a) = q_e$.
  \end{itemize}
  \marginpar{\writedown Довършете доказателството!}
  Сега лесно може да се докаже, че $\L(\A) = \L(\A')$.
\end{proof}

\begin{prop}
  \label{pr:automata-union}
  Класът на автоматните езици е затворен относно операцията {\em обединение}.
  Това означава, че ако $L_1$ и $L_2$ са два произволни автоматни езика над азбуката $\Sigma$, то $L_1\cup L_2$
  също е автоматен език.
\end{prop}
\begin{proof}
  \marginpar{Защо изискваме $\A_1$ и $\A_2$ да са тотални?}
  Нека $L_1 = \L(\A_1)$ и $L_2 = \L(\A_2)$, 
  където \[\A_1 = \FAn{1},\ \A_2 = \FAn{2}\] са {\em тотални}.
  Определяме автомата $\A = \FA$, който разпознава $L_1\cup L_2$ по следния начин:
  \begin{itemize}
  \item
    $Q = Q_1\times Q_2$;
  \item
    \marginpar{Едновременно симулираме изчисление и по двата автомата}
    \marginpar{По-нататък ще дадем друга конструкция за обединение, която ще бъде по-ефективна относно броя на състоянията}
    \marginpar{\writedown Проверете, че $\L(\A) = \L(\A_1)\cup \L(\A_2)$}
    Определяме за всяко $\pair{r_1,r_2} \in Q$ и всяко $a \in \Sigma$,
    \[\delta(\pair{r_1,r_2},a) = \pair{\delta_1(r_1,a),\delta_2(r_2,a)};\]
  \item
    $s = \pair{s_1,s_2}$;
  \item
    $F = \{\pair{r_1,r_2}\mid r_1\in F_1\vee r_2 \in F_2\} = (F_1\times Q_2)\cup (Q_1\times F_2)$.
  \end{itemize}
\end{proof}

\begin{cor}
  Класът на автоматните езици е затворен относно операцията {\bf сечение}.
  Това означава, че ако $L_1$ и $L_2$ са два произволни автоматни езика над азбуката $\Sigma$, то $L_1\cap L_2$
  също е автоматен език.
\end{cor}
\begin{proof}
  \marginpar{\ding{45} Докажете, че така построения автомат $\A$ разпознава $L_1\cap L_2$!}
  Използвайте конструкцията на автомата $\A$ от \Prop{automata-union},
  с единствената разлика, че тук избираме финалните състояния да бъдат елементите на множеството
  \[F = \{\pair{q_1,q_2} \mid q_1 \in F_1\ \&\ q_2 \in F_2\} = F_1\times F_2.\]
\end{proof}

\begin{prop}
  \label{pr:automata-complement}
  Нека $L$ е автоматен език.
  Тогава $\Sigma^\star\setminus L$ също е автоматен език.
\end{prop}
\begin{proof}
  \marginpar{Защо искаме $\A$ да бъде тотален ?}
  Нека $L = L(\A)$, където $\A = \FA$ е {\bf тотален}.
  Да вземем автомата $\A' = \pair{Q,\Sigma,s,\delta,Q\setminus F}$,
  т.е. $\A'$ е същия като $\A$, с единствената разлика, че финалните състояния на $\A'$
  са тези състояния, които {\bf не} са финални в $\A$.
  \marginpar{\writedown Проверете, че $\Sigma^\star\setminus L = \L(\A')$}
\end{proof}


\begin{example}
  \label{ex:automata-pictures}
  Да разгледаме няколко примера за автомати и езиците, които разпознават.
  Дефинирайте функцията на преходите $\delta$ за всеки автомат.

  \begin{figure}[H]
    \begin{subfigure}[b]{0.5\textwidth}
      \begin{tikzpicture}[->,>=stealth,thick,node distance=45pt]
        \tikzstyle{every state}=[circle,minimum size=20pt,auto]
        
        \node[initial below, state]   (0) {$s$};
        \node[state]            (1) [right of=0]{$q_1$};
        \node[state]            (2) [right of=1]{$q_2$};
        \node[state,accepting]  (3) [right of=2]{$q_3$};
        
        \path 
        (0) edge [loop above]   node [above] {$a$}    (0)
        (0) edge [bend left=15] node [above] {$b$}    (1)
        (1) edge [loop above]   node [above] {$b$}    (1)
        (1) edge [bend left=15] node [above] {$a$}    (2)
        (2) edge [bend left=30] node [below] {$a$}    (0)
        (2) edge [bend left=15] node [above] {$b$}    (3)
        (3) edge [loop above]   node [above] {$a,b$}  (3);
      \end{tikzpicture}
      \caption{$\{\omega \in \{a,b\}^\star \mid \omega\mbox{ съдържа }bab\}$}
    \end{subfigure}
    \quad
    \begin{subfigure}[b]{0.4\textwidth}
      \begin{tikzpicture}[->,>=stealth,thick,node distance=45pt]
        \tikzstyle{every state}=[circle,minimum size=20pt,auto]
        
        \node[initial below, state]   (0) {$s$};
        \node[state]            (1) [right of=0]{$q_1$};
        \node[state,accepting]  (2) [right of=1]{$q_2$};
        
        \path 
        (0) edge [loop above]   node [above] {$b$}    (0)
        (0) edge [bend left=15] node [above] {$a$}    (1)
        (1) edge [loop above]   node [above] {$b$}    (1)
        (1) edge [bend left=15] node [above] {$a$}    (2)
        (2) edge [loop above]   node [above] {$a,b$}  (2);
      \end{tikzpicture}
      \caption{$\{\omega \in \{a,b\}^\star \mid N_a(\omega) \geq 2\}$}
    \end{subfigure}
    \begin{subfigure}[b]{0.5\textwidth}
      \begin{tikzpicture}[->,>=stealth,thick,node distance=45pt]
        \tikzstyle{every state}=[circle,minimum size=20pt,auto]
        
        \node[initial below, accepting, state] (0) {$s$};
        \node[state]                     (1) [right of=0]{$q_1$};
        
        \path 
        (0) edge [loop above]   node [above] {$b$}   (0)
        (0) edge [bend left=15] node [above] {$a$}   (1)
        (1) edge [bend left=15] node [below] {$b$}   (0);
      \end{tikzpicture}
      \caption{$\{\omega \in \{a,b\}^\star \mid $ всяко $a$ в $\omega$ се следва от поне едно $b\}$ }
    \end{subfigure}
    \qquad
    \begin{subfigure}[b]{0.5\textwidth}
      \begin{tikzpicture}[->,>=stealth,thick,node distance=45pt]
        \tikzstyle{every state}=[circle,minimum size=20pt,auto]
        
        \node[initial below, state, accepting]   (0) {$s$};
        \node[state]                       (1) [right of=0]{$q_1$};
        \node[state]                       (2) [right of=1]{$q_2$};
        
        \path 
        (0) edge [loop above]   node   [above] {$b$}    (0)
        (0) edge [bend left=15] node   [above] {$a$}    (1)
        (1) edge [loop above]   node   [above] {$b$}    (1)
        (1) edge [bend left=15] node   [above] {$a$}    (2)
        (2) edge [loop above]   node   [above] {$b$}    (2)
        (2) edge [bend left=30] node   [below] {$a$}    (0);
      \end{tikzpicture}
      \caption{$\{\omega \in \{a,b\}^\star \mid N_a(\omega) \equiv 0\ (\bmod\ 3)\}$}
    \end{subfigure}
  \end{figure}    
\end{example}

В повечето от горните примери може сравнително лесно да се съобрази, че построения автомат разпознава желания език.
При по-сложни задачи обаче, ще се наложи да дадем доказателство, като обикновено се прилага 
{\em метода на математическата индукция} върху дължината на думите.
Ще разгледаме няколко такива примера.

\begin{problem}
  Докажете, че езикът $L$ е автоматен, където
  \[L = \{\alpha \in \{a,b\}^\star\ \mid\ \alpha\mbox{ не съдържа две поредни срещания на }a\}.\]
\end{problem}
\begin{proof}
  \marginpar{Най-лесния начин да се сетим как да построим $\A$ е като първо построим тотален автомат за езика, който разпознава тези думи, в които се съдържат две поредни срещания на $a$ и вземем неговото допълнение съгласно Твърдение \ref{pr:automata-complement}}
  Да разгледаме $\A = \FA$ с функция на преходите
  \begin{figure}[H]
    \begin{center}
      \begin{tikzpicture}[->,>=stealth,thick,node distance=45pt]
        \tikzstyle{every state}=[circle,minimum size=20pt,auto]
        
        \node[initial, accepting, state] (0) {$s$};
        \node[accepting, state]   (1) [right of=0]{$q_1$};
        \node[state]   (2) [right of=1]{$q_2$};
        
        \path 
        (0) edge [loop above]   node [above] {$b$}   (0)
        (0) edge [bend left=15] node [above] {$a$}   (1)
        (1) edge [bend left=15] node [below] {$b$}   (0)
        (1) edge [bend left=15] node [above] {$a$}   (2)
        (2) edge [loop above]   node [above] {$a,b$} (2);
      \end{tikzpicture}
    \end{center}
 \end{figure}

 Ще докажем, че $L = \L(\A)$.
 Първо ще се концентрираме върху доказателството на $\L(\A) \subseteq L$.
 \marginpar{Озн. $\abs{\alpha}$ - дължината на думата $\alpha$}
 Ще докажем с индукция по дължината на думата $\alpha$, че:
 \begin{enumerate}[(1)]
 \item 
   ако $\delta^\star(s,\alpha) = s$, то
   $\alpha$ не съдържа две поредни срещания на $a$
   и ако $\abs{\alpha} > 0$, то $\alpha$ завършва на $b$;
 \item
   ако $\delta^\star(s,\alpha) = q_1$, то
   $\alpha$ не съдържа две поредни срещания на $a$
   и завършва на $a$.
 \end{enumerate}

 За $\abs{\alpha} = 0$, то твърденията (1) и (2) са ясни (Защо?).
 Да приемем, че твърденията $(1)$ и $(2)$ са верни за произволни думи $\alpha$ с дължина $n$.
 Нека $\abs{\alpha} = n+1$, т.е. $\alpha = \beta x$, където $\abs{\beta} = n$ и $x \in \Sigma$.
 Ще докажем (1) и (2) за $\alpha$.
 \begin{itemize}[-]
 \item 
   Нека $\delta^\star(s,\beta x) = s = \delta(\delta^\star(s,\beta),x)$.
   Според дефиницията на функцията $\delta$, $x = b$ и $\delta^\star(s,\beta) \in \{s,q_1\}$.
   Тогава по {\bf И.П.} за (1) и (2), $\beta$ не съдържа две поредни срещания на $a$.
   Тогава е очевидно, че $\beta x$ също не съдържа две поредни срещания на $a$.
 \item
   Нека $\delta^\star(s,\beta x) = q_1 = \delta(\delta^\star(s,\beta),x)$.
   Според дефиницията на $\delta$, $x = a$ и $\delta^\star(s,\beta) = s$.
   Тогава по {\bf И.П.} за (2), $\beta$ не съдържа две поредни срещания на $a$
   и завършва на $b$.
   Тогава е очевидно, че $\beta x$ също не съдържа две поредни срещания на $a$.
 \end{itemize}
 
 Така доказахме с индукция по дължината на думата, че за всяка дума $\alpha$
 са  изпълнени твърденията $(1)$ и $(2)$. По дефиниция, ако $\alpha \in \L(\A)$,
 то $\delta^\star(s,\alpha) \in \{s,q_1\}$ и от $(1)$ и $(2)$ следва, че и в двата случа
 $\alpha$ не съдържа две поредни срещания на буквата $a$, т.е. $\alpha \in L$.
 С други думи, доказахме, че 
 \[\L(\A) \subseteq L.\]

 Сега ще докажем другата посока, т.е. $L \subseteq \L(\A)$.
 Това означава да докажем, че
 \[(\forall \alpha \in \Sigma^\star)[\alpha \in L\ \Rightarrow\ \delta^\star(s,\alpha) \in F],\]
 \marginpar{Да напомним, че $p \Rightarrow q \equiv \neg q \Rightarrow \neg  p$}
 което е еквивалентно на
 \begin{equation}
   \label{eq:case2}
   (\forall \alpha \in \Sigma^\star)[\delta^\star(s,\alpha) \not\in F \ \Rightarrow\ \alpha\not\in L].
 \end{equation}
 Това е лесно да се съобрази.
 Щом $\delta^\star(s,\alpha) \not\in F$, то 
 $\delta^\star(s,\alpha) = q_2$ и думата $\alpha$ може да се представи по следния начин:
 \[\alpha = \beta a \gamma\ \&\ \delta^\star(s,\beta) = q_1.\]
 
 Използвайки свойство (2) от по-горе, понеже $\delta^\star(s,\beta) = q_1$, то
 $\beta$ не съдържа две поредни срещания на $a$, но завършва на $a$.
 Сега е очевидно, че $\beta a$ съдържа две поредни срещания на $a$ и 
 щом $\beta a$ е префикс на $\alpha$, то думата $\alpha \not\in L$.
 С това доказахме Свойство \ref{eq:case2}, а следователно и посоката $L\subseteq \L(\A)$.
\end{proof}

\begin{problem}
  Докажете, че следния език е автоматен:
  \[L = \{w \in \{a,b\}^\star \mid a \text{ се среща четен брой, докато $b$ нечетен брой пъти в }w\}.\]
\end{problem}
\begin{hint}
  Разгледайте автомата $\A$:
  \begin{figure}[H]
    \begin{center}
      \begin{tikzpicture}[->,>=stealth,thick,node distance=50pt]
        \tikzstyle{every state}=[circle,minimum size=15pt,auto]
        
        \node[initial,state]      (00) {$00$};
        \node[state]              (10) [above right of=00]{$10$};
        \node[accepting, state]   (01) [below right of=00]{$01$};
        \node[state]              (11) [below right of=10]{$11$};
        
        \path 
        (00) edge  [bend left=15]  node [above]  {$a$} (10)
        (10) edge  [bend left=15]  node [below]  {$a$} (00)
        (01) edge  [bend right=15]  node [above]  {$b$} (00)
        (00) edge  [bend right=15]  node [below]  {$b$} (01)
        (10) edge  [bend left=15]  node [above]  {$b$} (11)
        (11) edge  [bend left=15]  node [below]  {$b$} (10)
        (01) edge  [bend right=15]  node [below]  {$a$} (11)
        (11) edge  [bend right=15]  node [above]  {$a$} (01);
      \end{tikzpicture}
    \end{center}
    \caption{$\L(\A) \stackrel{?}{=} L$}
  \end{figure}
  Докажете с индукция по дължината на думата $w$, че:
  \begin{enumerate}[a)]
  \item 
    $\delta^\star(00, w) = 00 \implies (\exists k,n\in\Nat)[N_a(w) = 2k\ \&\ N_b(w) = 2n]$;
  \item 
    $\delta^\star(00, w) = 01 \implies (\exists k,n\in\Nat)[N_a(w) = 2k\ \&\ N_b(w) = 2n+1]$;
  \item 
    $\delta^\star(00, w) = 10 \implies (\exists k,n\in\Nat)[N_a(w) = 2k+1\ \&\ N_b(w) = 2n]$;
  \item 
    $\delta^\star(00, w) = 11 \implies (\exists k,n\in\Nat)[N_a(w) = 2k+1\ \&\ N_b(w) = 2n+1]$;
  \end{enumerate}
\end{hint}


\begin{problem}
  Докажете, че езикът $L = \{w \in \{0,1\}^\star \mid |w| \equiv 1 \bmod 3\}$ е автоматен.
\end{problem}
\begin{hint}
  \marginpar{$|w| = $ дължината на думата $w$}
  Разгледайте автомата $\A$:
  \begin{figure}[H]
    \begin{center}
      \begin{tikzpicture}[->,>=stealth,thick,node distance=45pt]
        \tikzstyle{every state}=[circle,minimum size=15pt,auto]
        
        \node[initial,state]      (0) {$q_0$};
        \node[accepting, state]              (1) [right of=0]{$q_1$};
        \node[state]   (2) [right of=1]{$q_2$};
        
        \path 
        (0) edge  [bend left=15]  node [above]  {$0,1$} (1)
        (1) edge  [bend left=15]  node [above]  {$0,1$} (2)
        (2) edge  [bend left=30]  node [below]  {$0,1$} (0);
      \end{tikzpicture}
      \end{center}
      \caption{$\L(\A) \stackrel{?}{=} \{w\in\{0,1\}^\star \mid |w| \equiv 1 \bmod 3\}$}
 \end{figure}  
 Докажете с индукция по дължината на думата $w$ едновременно следните три твърдения:
 \begin{enumerate}[(1)]
 \item
   $\delta^\star(q_0, w) = q_0 \implies |w| \equiv 0 \bmod 3$;
 \item 
   $\delta^\star(q_0, w) = q_1 \implies |w| \equiv 1 \bmod 3$;
 \item
   $\delta^\star(q_0, w) = q_2 \implies |w| \equiv 2 \bmod 3$.
 \end{enumerate}
\end{hint}

За една дума $\alpha \in \{0,1\}^\star$, 
нека с $\alpha_{(2)}$ да означим числото в десетична бройна система, което се представя в двоична бройна система като $\alpha$.
Например, $1101_{(2)} = 1 \cdot 2^3+1\cdot 2^2+0\cdot 2^1+1\cdot 2^0 = 13$.
Тогава имаме следните свойства:
\begin{itemize}
\item
  $\varepsilon_{(2)} = 0$,
\item
  $(\alpha0)_{(2)} = 2\cdot(\alpha)_{(2)}$,
\item
  $(\alpha1)_{(2)} = 2\cdot(\alpha)_{(2)} + 1$.
\end{itemize}
\marginpar{Да отбележим, че за всяко число $n$ има безкрайно много думи $\alpha$, за които $\alpha_{(2)} = n$. Например, $10_{(2)} = 010_{(2)} = 0010_{(2)} = \cdots$}

\begin{problem}
  Докажете, че $L = \{\omega \in \{0,1\}^\star \mid \omega_{(2)} \equiv 2\ (\bmod\ 3)\}$ е автоматен.
\end{problem}
\begin{proof}
  Нашият автомат ще има три състояния $\{q_0,q_1,q_2\}$, като началното състояние ще бъде $q_0$.
  Целта ни е да дефинираме така автомата, че да имаме следното свойство:
  \begin{equation}
    (\forall\alpha\in\Sigma^\star)(\forall i < 3)[\alpha_{(2)} \equiv i\ (\bmod\ 3)\ \Leftrightarrow\ \delta^\star(q_0,\alpha) = q_i],
  \end{equation}
  т.е. всяко състояние отговаря на определен остатък при деление на три.
  Понеже искаме нашия автомат да разпознава тези думи $\alpha$,
  за които $\alpha_{(2)} \equiv 2\mod 3$, финалното състояние ще бъде $q_2$.
  Дефинираме функцията $\delta$ следвайки свойствата:
  \begin{itemize}
  \item
    $\delta(q_0,0) = q_0$, защото ако $\alpha_{(2)} \equiv 0 \bmod 3$, то $(\alpha0)_{(2)} \equiv 0 \bmod 3$;
  \item 
    $\delta(q_0,1) = q_1$, защото ако $\alpha_{(2)} \equiv 0 \bmod 3$, то $(\alpha1)_{(2)} \equiv 1 \bmod 3$;
  \item
    $\delta(q_1,0) = q_2$, защото ако $\alpha_{(2)} \equiv 1 \bmod 3$, то $(\alpha0)_{(2)} \equiv 2 \bmod 3$;
  \item 
    $\delta(q_1,1) = q_0$, защото ако $\alpha_{(2)} \equiv 1 \bmod 3$, то $(\alpha1)_{(2)} \equiv 0 \bmod 3$;
  \item
    $\delta(q_2,0) = q_1$, защото ако $\alpha_{(2)} \equiv 2 \bmod 3$, то $(\alpha0)_{(2)} \equiv 1 \bmod 3$;
  \item 
    $\delta(q_2,1) = q_2$, защото ако $\alpha_{(2)} \equiv 2 \bmod 3$, то $(\alpha1)_{(2)} \equiv 2 \bmod 3$.
  \end{itemize}
  Ето и картинка на автомата $\A$:
  \begin{framed}
  \begin{figure}[H]
    \begin{center}
      \begin{tikzpicture}[->,>=stealth,thick,node distance=45pt]
        \tikzstyle{every state}=[circle,minimum size=15pt,auto]
        
        \node[initial,state]      (0) {$q_0$};
        \node[state]              (1) [right of=0]{$q_1$};
        \node[accepting, state]   (2) [right of=1]{$q_2$};
        
        \path 
        (0) edge  [loop above]    node [above]  {$0$} (0)
        (0) edge  [bend left=15]  node [above]  {$1$} (1)
        (2) edge  [bend left=15] node [below]  {$0$} (1)
        (1) edge  [bend left=15]  node [below]  {$1$} (0)
        (1) edge  [bend left=15] node [above]  {$0$} (2)
        (2) edge  [loop above]    node [above]  {$1$} (2);
      \end{tikzpicture}
      \end{center}
      \caption{$\L(\A) \stackrel{?}{=} \{\alpha\in\{0,1\}^\star \mid \alpha_{(2)} \equiv 2\ (\bmod\ 3)\}$}
 \end{figure}
 \end{framed}
 \noindent Да разгледаме твърденията:
 \begin{enumerate}[(1)]
  \item 
    $\delta^\star(q_0,\alpha) = q_0 \implies \alpha_{(2)} \equiv 0 \mod 3$;
  \item 
    $\delta^\star(q_0,\alpha) = q_1 \implies \alpha_{(2)} \equiv 1 \mod 3$;
  \item 
    $\delta^\star(q_0,\alpha) = q_2 \implies \alpha_{(2)} \equiv 2 \mod 3$.
  \end{enumerate}
  Ще докажем (1), (2) и (3) {\em едновременно} с индукция по дължината на думата $\alpha$.
  За $\abs{\alpha} = 0$, всички условия са изпълнени. (Защо?)
  Да приемем, че (1), (2) и (3) са изпълнени за думи с дължина $n$.
  Нека $\abs{\alpha} = n+1$, т.е. $\alpha = \beta x$, $\abs{\beta} = n$.
  За да приложим индукционното предположение, ще използваме следното свойство:
  \[\delta^\star(q_0,\beta x) = \delta(\delta^\star(q_0,\beta),x).\]
  
  Ще докажем подробно само (3) понеже другите твърдения се доказват по сходен начин.
  \marginpar{Обърнете внимание, че в доказателството на (3) използваме И.П. не само за (3), но и за (2). Поради тази причина трябва да докажем трите свойства едновременно}
  Нека $\delta^\star(q_0,\beta x) = q_2$. 
  Имаме два случая:
  \begin{itemize}
  \item 
    $x = 0$. 
    Тогава, по дефиницията на $\delta$, 
    $\delta(q_1,0) = q_2$ и следователно, $\delta^\star(q_0,\beta) = q_1$.
    По {\bf И.П.} за (2) с $\beta$,
    \[\delta^\star(q_0,\beta) = q_1\ \Rightarrow\ \beta_{(2)} \equiv 1 \bmod 3\]
    Тогава, $(\beta0)_{(2)} \equiv 2 \mod 3$. Така доказахме, че
    \[\delta^\star(q_0,\beta 0) = q_2\ \Rightarrow\ (\beta 0)_{(2)} \equiv 2 \bmod 3.\]
  \item
    $x = 1$.
    Тогава, по дефиницията на $\delta$, $\delta(q_2,1) = q_2$ и следователно,
    $\delta^\star(q_0,\beta) = q_2$.
    По {\bf И.П.} за (3) с $\beta$,
    \[\delta^\star(q_0,\beta) = q_2\ \Rightarrow\ \beta_{(2)} \equiv 2 \mod 3.\]
    Тогава, $(\beta1)_{(2)} \equiv 2 \mod 3$. Така доказахме, че
    \[\delta^\star(q_0,\beta 1) = q_2\ \Rightarrow\ (\beta 1)_{(2)} \equiv 2 \mod 3.\]
  \end{itemize}
  
  За да докажем (1), нека $\delta^\star(q_0,\beta x) = q_0$. 
  \begin{itemize}
  \item 
    $x = 0$. Разсъжденията са аналогични, като използваме {\bf И.П.} за (1).
  \item
    $x = 1$. Разсъжденията са аналогични, като използваме {\bf И.П.} за (2).
  \end{itemize}
  
  По същия начин доказваме и (2). Нека $\delta^\star(q_0,\beta x) = q_1$. 
  \begin{itemize}
  \item 
    При $x = 0$, използваме {\bf И.П.} за (3).
  \item
    При $x = 1$, използваме {\bf И.П.} за (1).
  \end{itemize}

  От (1), (2) и (3) следва директно, че $\L(\A) \subseteq L$.
  
  За другата посока, нека $\alpha \in L$, т.е. $\alpha_{(2)} \equiv 2 \bmod 3$.
  Ако допуснем, че $\alpha \not\in \L(\A)$, то това означава, че $\delta^\star(q_0,\alpha) \in \{q_0,q_1\}$.
  Но в тези случаи получаваме от твърдения (1) и (2), че $\alpha_{(2)} \equiv 0 \bmod 3$ или $\alpha_{(2)} \equiv 1 \bmod 3$.
  Това е противоречие с избора на $\alpha \in L$. Следователно, ако $\alpha \in L$, то $\delta(q_0,\alpha) = q_2$.
  Така доказахме и посоката $L \subseteq \L(\A)$.
\end{proof}

\section{Регулярни изрази и езици}

Да фиксираме една непразна азбука $\Sigma$.
\index{регулярен израз}
{\bf Регулярните изрази} $\mathbf{r}$ могат да се опишат със следната абстрактна граматика
\[\mathbf{r} ::= \emptyset\ |\ \varepsilon\ |\ a\ |\ \mathbf{ r_1 \cdot r_2}\ |\ \mathbf{r_1 + r_2}\ |\ \mathbf{r^\star_1},\]
където $\varepsilon$ означава празната дума и $a$ е произволна буква от азбуката $\Sigma$.

Друг начин да се опишат регулярните изрази е по следния начин:
\marginpar{Това е пример за индуктивна дефиниция}
\begin{itemize}
\item 
  Символите $\emptyset$, $\varepsilon$ и всяко $a \in \Sigma$ са регулярен изрази;
\item
  Ако $\mathbf{r_1}$ и $\mathbf{r_2}$ са регулярни изрази, то $\mathbf{r_1 \cdot r_2}$, $\mathbf{r_1 + r_2}$ и $\mathbf{r^\star_1}$
  също са регулярни изрази.
\end{itemize}

\index{език!регулярен}
\marginpar{Това е друг пример за индуктивна (рекурсивна) дефиниция.}
Сега ще дефинираме езиците, които се описват с регулярни изрази.
Тези езици се наричат {\bf регулярни}.
Това ще направим следвайки индуктивната дефиниция на регулярните изрази,
т.е. за всеки регулярен израз $\mathbf{r}$ ще определим език $\L(\mathbf{r})$.
\begin{itemize}
\item
  $\{\varepsilon\}$ е регулярен език,
  който се разпознава от регулярния израз $\varepsilon$.
  Означаваме $\L(\varepsilon) = \{\varepsilon\}$;
\item
  за всяка буква $a \in \Sigma$, $\{a\}$ е регулярен език,
  който се разпознава от регулярния израз $a$.
  Означаваме $\L(a) = \{a\}$;
\item
  $\emptyset$ е регулярен език,
  който се разпознава от регулярния израз $\emptyset$. Означаваме $\L(\emptyset) = \emptyset$;
\item
  Нека $L_1$ и $L_2$ са регулярни езици, т.е. съществуват регулярни изрази $\mathbf{r_1}$
  и $\mathbf{r_2}$, за които $\L(\mathbf{r}_1) = L_1$ и $\L(\mathbf{r_2}) = L_2$.
  Тогава:
  \begin{itemize}
  \item 
    \index{обединение}
    $L_1 \cup L_2$ е регулярен език, който се описва с регулярния израз $\mathbf{r_1 + r_2}$.
    Това означава, че $\L(\mathbf{r_1}) \cup \L(\mathbf{r_2}) = \L(\mathbf{r_1+r_2})$.
  \item
    \index{конкатенация}
    \marginpar{Тази операция се наричка конкатенация. Обикновено изпускаме знака $\cdot$}
    $L_1 \cdot L_2$ е регулярен език, който се описва с регулярния израз $\mathbf{r_1 \cdot r_2}$.
    Това означава, че $\L(\mathbf{r_1}) \cdot \L(\mathbf{r_2}) = \L(\mathbf{r_1 \cdot r_2})$.
  \item
    \marginpar{Звезда на Клини}
    \index{звезда на Клини}
    $L^\star_1$ е регуларен език, който се описва с регулярния израз $\mathbf{r^\star_1}$.
    Това означава, че $L^\star_1 = \L(\mathbf{r^\star_1})$.
  \end{itemize}
\end{itemize}

\begin{remark}
  Ние знаем, че:
  \begin{itemize}
  \item 
    $\Sigma^\star$ е изброимо безкрайно множество;
  \item
    всички регулярни изрази са изброимо много, откъдето следва, че всички регулярни езици са изброимо много;
  \item
    всички езици над азбуката $\Sigma$ са неизброимо много, защото един език представлява елемент на $\Ps(\Sigma^\star)$.
  \end{itemize}
  От всичко това следва, че има езици, които не са регулярни.
  По-нататък ще видим примери за такива езици.
\end{remark}

\begin{example}
  Нека да разгледаме няколко примера какво точно представлява прилагането
  на операцията звезда на Клини върху един език.
  \begin{itemize}
  \item 
    Нека $L = \{0,11\}$. Тогава:
    \begin{itemize}
    \item 
      $L^0 = \{\varepsilon\}$, $L^1 = L$,
    \item
      $L^2 = L^1\cdot L^1 = \{00,011,110,1111\}$,
    \item
      $L^3 = L^1\cdot L^2 = \{000,0011,0110,01111,1100,11011,11110,111111\}$.
    \end{itemize}
  \item
    Нека $L = \emptyset$.
    Тогава:
    \begin{itemize}
    \item 
      $L^0 = \{\varepsilon\}$,
    \item
      $L^1 = \emptyset$,
    \item
      $L^2 = L^1 \cdot L^1 = \emptyset$.
    \end{itemize}    
    Получаваме, че $L^\star = \{\varepsilon\}$, т.е. {\em краен} език
  \item
    Нека $L = \{0^i\mid i \in \Nat\} = \{\varepsilon, 0, 00, 000, \dots\}$.
    Тогава лесно може да се види, че $L = L^\star$.
  \end{itemize}
\end{example}

\begin{example}
  \marginpar{В \cite[стр. 73]{sipser1} е показан алгоритъм, за който по един автомат може да се получи регулярен израз описващ езика на автомата. Ние няма да разглеждаме този алгоритъм. }
  Нека да построим регулярни изрази за всеки от езиците от \Ex{automata-pictures}.
  \begin{enumerate}[a)]
  \item 
    Нека $\mathbf{r} = \mathbf{(a+b)^\star bab(a+b)^\star}$. Тогава
    \[\L(\mathbf{r}) = \{\omega \in \{a,b\}^\star \mid \omega \text{ съдържа } bab\}.\]
  \item
    Нека $\mathbf{r} = \mathbf{b^\star ab^\star a(a+b)^\star}$. Тогава
    \[\L(\mathbf{r}) = \{\omega \in \{a,b\}^\star \mid N_a(\omega) \geq 2\}.\]
  \item
    Нека $\mathbf{r} = \mathbf{(abb^\star)^\star}$. Тогава
    \[\L(\mathbf{r}) = \{\omega \in \{a,b\}^\star \mid \text{ всяко $a$ в $\omega$ се следва от поне едно $b$}\}.\]
  \item
    Нека $\mathbf{r} = \mathbf{(b^\star ab^\star ab^\star ab^\star)^\star}$. Тогава
    \[\L(\mathbf{r}) = \{\omega \in \{a,b\}^\star \mid N_a(\omega) \equiv 0 \bmod 3\}.\]
  \end{enumerate}
\end{example}


\begin{problem}
  За произволни регулярни изрази $r$ и $s$, 
  проверете:
  \begin{enumerate}[a)]
  \item 
    $r+s = s + r$;
  \item
    $(\varepsilon + r)^\star = r^\star$;
  \item
    $\emptyset^\star = \varepsilon$;
  \item
    $(r^\star s^\star) = (r+s)^\star$;
  \item
    \marginpar{\ding{45} Проверете!}
    $(r^\star)^\star = r^\star$;
  \item
    $(rs + r)^\star r = r(sr+r)^\star$;
  \item
    $s(rs+s)^\star r = rr^\star s(rr^\star s)^\star$;
  \item
    $(r+s)^\star = r^\star + s^\star$;
  \item
    $\emptyset^\star = \varepsilon^\star$;
  \end{enumerate}
\end{problem}

\begin{framed}
\begin{thm}[Клини]
  \label{th:regular-kleene}
  \index{Клини}
  Всеки автоматен език се описва с регулярен израз.
\end{thm}
\end{framed}
\begin{proof}
  \marginpar{\cite[стр. 79]{papadimitriou}; \cite[стр. 33]{hopcroft1}}
  Нека  $L = \L(\A)$, за някой краен детерминиран автомат $\A$.
  Да фиксираме едно изброяване на състоянията $Q = \{q_1,\dots,q_n\}$,
  като началното състояние е $q_1$.
  Ще означаваме с $L(i,j,k)$ множеството от тези думи, които
  могат да се разпознаят от автомата по път, който започва от $q_i$,
  завършва в $q_j$, и междинните състояния имат индекси $\leq k$.
  Например, за думата $\alpha = a_1a_2\cdots a_n$ имаме, че $\alpha \in L(i,j,k)$
  точно тогава, когато съществуват състояния $q_{l_1},\dots,q_{l_{n-1}}$, като $l_1,\dots,l_{n-1} \leq k$ и
  \[q_i\stackrel{a_1}{\rightarrow} q_{l_1} \stackrel{a_2}{\rightarrow} q_{l_2} \stackrel{a_3}{\rightarrow} \dots \stackrel{a_{n-1}}{\rightarrow} q_{l_{n-1}}\stackrel{a_n}{\rightarrow} q_j.\]
  Тогава за $n = \abs{Q}$, 
  \[L(i,j,n) = \{\alpha\in\Sigma^\star\mid \delta^\star(q_i,\alpha) = q_j\}.\]
  Така получаваме, че 
  \[\L(\A) = \bigcup\{L(1,j,n)\mid q_j \in F\} = \bigcup_{q_j\in F}L(1,j,n).\]
  Ще докажем с {\em индукция по $k$}, че за всяко $i,j,k$, множествата от думи $L(i,j,k)$
  се описват с регулярен израз $\mathbf{r^k_{i,j}}$
  \begin{enumerate}[a)]
  \item
    Нека $k = 0$. Ще докажем, че за всяко $i,j$, $L(i,j,0)$ се описва с регулярен израз.
    Имаме да разгледаме два случая.
    
    Ако $i = j$, то 
    \begin{equation}
      \label{eq:kleene-equal}
      L(i, j, 0) = \{\varepsilon\}\cup\{a\in\Sigma \mid \delta(q_i,a) = q_j\}.
    \end{equation}
    Ако $i \neq j$, то
    \[L(i, j, 0) = \{a\in\Sigma \mid \delta(q_i, a) = q_j\}.\]
    И в двата случая, понеже $L(i,j,0)$ е краен език, то е ясно, че той се описва с регулярен израз.
  \item
    Да предположим, че $k > 0$ и за всяко $i$, $j$, можем да намерим регулярните изрази
    съответстващи на $L(i,j,k-1)$. Тогава
    \[L(i,j,k) = L(i,j,k-1)\ \cup\ L(i,k,k-1)\cdot (L(k,k,k-1)^\star) \cdot L(k,j,k-1).\]
    Тогава по {\bf И.П.} следва, че $L(i,j,k)$ може да се опише с регулярен израз, който е
    \begin{equation}
      \label{eq:kleene}
      \mathbf{r^k_{i,j}} = \mathbf{r^{k-1}_{i,j} + r^{k-1}_{i,k}\cdot (r^{k-1}_{k,k})^\star\cdot r^{k-1}_{k,j}}.
    \end{equation}
  \end{enumerate}
  Заключаваме, че за всяко $i,j,k$, $L(i,j,k)$ може да се опише с регулярен израз $\mathbf{r^{k}_{i,j}}$.
  Тогава ако $F = \{q_{i_1},\dots,q_{i_k}\}$, то $\L(\A)$ се описва с регулярния израз
  \[\mathbf{r^n_{1,i_1} + r^n_{1,i_2} + \dots + r^n_{1,i_k}}.\]
\end{proof}

\begin{example}
  \label{fig:a1}
  Да разгледаме следния автомат:
  
  \begin{figure}[H]
    \begin{center}
      \begin{tikzpicture}[->,>=stealth,thick,node distance=45pt]
        \tikzstyle{every state}=[circle,minimum size=15pt,auto]
        
        \node[initial,state]      (1) {$q_1$};
        \node[accepting, state]   (2) [right of=1]{$q_2$};
        
        \path 
        (1) edge [loop above]  node [above] {$1$} (1)
        (1) edge  node [above] {$0$} (2)
        (2) edge [loop above] node [above] {$0,1$} (2);
      \end{tikzpicture}
      \end{center}
 \end{figure}

 Ясно е, езикът на автомата от Пример \ref{fig:a1} се описва с регулярния израз $\mathbf{1^\star 0 (0 + 1)^\star}$.
 % За да намерим регулярния език за автомата от Пример \ref{fig:a1}, 
 Следвайки конструкцията от доказателството на \Th{regular-kleene},
 езикът на този автомат се описва с регулярния израз $\mathbf{r^2_{1,2}}$, защото началното състояние е $q_1$, финалното е $q_2$ и 
 броят на състоянията в автомата е $2$.
 \begin{align*}
   \mathbf{r^2_{1,2}} & = \underbrace{\mathbf{r^{1}_{1,2}}}_{\mathbf{1^\star 0}} + \underbrace{\mathbf{r^{1}_{1,2}}}_{\mathbf{1^\star 0}}\cdot \underbrace{\mathbf{(r^1_{2,2})^\star}}_{\mathbf{(\varepsilon+0+1)^\star}} \cdot \underbrace{\mathbf{r^1_{2,2}}}_{\mathbf{\varepsilon+0+1}} & (\text{според (\ref{eq:kleene}})) \\
   &  = \mathbf{1^\star0 + 1^\star 0 (\varepsilon + 0 + 1)^\star (\varepsilon + 0 + 1)}\\
   & =  \mathbf{1^\star0 + 1^\star 0 (\varepsilon + 0 + 1)^+} & (\mathbf{r^+ = r^\star r})\\
   & =  \mathbf{1^\star0 + 1^\star 0 (0 + 1)^\star} & (\mathbf{r^\star = (\varepsilon + r)^+})\\
   & = \mathbf{1^\star 0 (\varepsilon + (0 + 1)^\star)} & (\mathbf{r + rq = r(\varepsilon + q)})\\
   & = \mathbf{1^\star 0 (0 + 1)^\star} & (\mathbf{r^\star = \varepsilon + r^\star})
  \end{align*}
  
  Тук използвахме, че:
  \begin{align*}
    \mathbf{r^1_{1,2}} & = \underbrace{\mathbf{r^0_{1,2}}}_{\mathbf{0}} + \underbrace{\mathbf{r^0_{1,1}}}_{\mathbf{\varepsilon + 1}}\cdot\underbrace{\mathbf{(r^0_{1,1})^\star}}_{\mathbf{(\varepsilon+1)^\star}} \cdot \underbrace{\mathbf{r^0_{1,2}}}_{\mathbf{0}}\\
    & = \mathbf{0 + (\varepsilon + 1)(\varepsilon + 1)^\star0} \\
    & = \mathbf{0 + 1^\star 0}\\
    & = \mathbf{1^\star0},\\
    \mathbf{r^1_{2,2}} & = \underbrace{\mathbf{r^0_{2,2}}}_{\mathbf{\varepsilon+0+1}} + \underbrace{\mathbf{r^0_{2,1}}}_{\mathbf{\emptyset}} \cdot \underbrace{\mathbf{(r^0_{1,1})^\star}}_{\mathbf{\varepsilon+1}}\cdot \underbrace{\mathbf{r^0_{1,2}}}_{\mathbf{0}}\\
    & = \mathbf{\varepsilon + 0 + 1 + \emptyset(\varepsilon + 1)^\star0}\\
    & = \varepsilon + 0 + 1 & (\text{защото }\mathbf{\emptyset \cdot r = \emptyset})
  \end{align*}
\end{example}

Следващата ни цел е да видим, че имаме и обратната посока на горната лема.
Ще докажем, че всеки регулярен език е автоматен. За тази цел първо ще 
въведем едно обобщение на понятието краен детерминиран автомат.

\section{Недетерминирани крайни автомати}
\index{автомат!недетерминиран}
\begin{dfn}
  \marginpar{Въведени от Рабин и Скот \cite{rabin-scott}}
  \marginpar{За яснота, често ще означаваме с $\N$ недетерминирани автомати, а с $\A$ детерминирани автомати}
  Недетерминиран краен автомат представлява
  \[\N = \NFA,\]
  \begin{itemize}
  \item
    $Q$ е крайно множество от състояния;
  \item
    $\Sigma$ е крайна азбука;
  \item
    $\Delta: Q\times\Sigma \to \Ps(Q)$ е функцията на преходите.
    \marginpar{Да напомним, че $\Ps(Q) = \{R\mid R\subseteq Q\}$, $\abs{\Ps(Q)} = 2^{\abs{Q}}$}
    \marginpar{В \cite{sipser1} се позволяват $\epsilon$-преходи}
    Обърнете внимание, че тя е тотална.
  \item
    $s \in Q$ е началното състояние;
  \item
    $F\subseteq Q$ е множеството от финални състояния.
  \end{itemize}
\end{dfn}

Удобно е да разширим функцията на преходите $\Delta: Q\times\Sigma \to \Ps(Q)$ 
до функцията $\Delta^\star: Q\times\Sigma^\star \to \Ps(Q)$ по следния начин:
\begin{itemize}
\item 
  $\Delta^\star(q, \varepsilon) = \{q\}$;
\item
  \marginpar{Съобразете, че $\Delta^\star(q, \alpha b) = \bigcup_{p \in \Delta^\star(q,\alpha)} \Delta(p,b)$}
  $\Delta^\star(q, b\alpha) = \bigcup_{p \in \Delta(q,b)} \Delta^\star(p, \alpha)$;
\end{itemize}

\begin{framed}
\begin{thm}[Рабин-Скот \cite{rabin-scott}]
  За всеки НKА $\N$ съществува еквивалентен на него ДКА $\D$, т.е. $\L(\N) = \L(\D)$.
\end{thm}
\end{framed}
\begin{hint}
  Нека $\N = \NFA$. Ще построим детерминиран автомат
  \[\D = (Q',\Sigma,\delta,s',F'),\]
  за който $\L(\N) = \L(\D)$.
  Конструкцията е следната:
  \marginpar{Да отбележим, че детерминираният автомат $\D$ има не повече от $2^{\abs{Q}}$ на брой състояния $Q'$}
  \begin{itemize}
  \item
    $Q' = \Ps(Q)$;
  \item
    $\delta(R,a) = \{q\in Q\mid (\exists r\in R)[q\in\Delta(r,a)]\} = \bigcup_{r\in R}\Delta(r,a)$;
  \item
    $s' = \{s\}$;
  \item
    $F' = \{R \subseteq Q \mid R\cap F \neq \emptyset\}$.
  \end{itemize}
\end{hint}

% \begin{problem}
%   За дума $\alpha = a_1a_2\cdots a_n$, дефинираме $\alpha^R = a_na_{n-1}\cdots a_1$.
%   \marginpar{Индукция по $\abs{\beta}$.}
%   Докажете, че
%   \[(\forall \alpha,\beta\in\Sigma^\star)[(\alpha\beta)^R = \beta^R\alpha^R].\]
% \end{problem}

\begin{problem}
  За всеки НКА $\N$ съществува НКА $\N'$ с едно финално състояние, 
  за който $\L(\N) = \L(\N')$.
\end{problem}
\begin{hint}
  Вместо формална конструкция, да разгледаме един пример, който илюстрира идеята.
  \begin{figure}[H]
    \begin{subfigure}[b]{0.3\textwidth}
      \begin{tikzpicture}[framed,->,>=stealth,thick,node distance=45pt]
        \tikzstyle{every state}=[circle,minimum size=20pt,auto]
        \node[initial,state]      (1) {$s$};
        \node[state,accepting]     [above right of=1] (2) {$q_1$};
        \node[state,accepting]     [below right of=1] (3) {$q_2$};
        \path
        (1) edge [bend left=15] node  [above] {$a$} (2)
        (2) edge [bend left=15] node  [right] {$b$} (1)
        % (2) edge [loop above] node  [above] {$a$} (2)
        (2) edge [bend left=15] node  [right] {$a$} (3)
        (3) edge [bend left=15] node  [below] {$a$} (1)
        (3) edge [loop below] node  [right] {$b$} (3);
        % (1) edge [bend right=15] node [below] {$b$} (3);
      \end{tikzpicture}
      \caption{автомат $\N$}
    \end{subfigure}
    \qquad
    \qquad
    \begin{subfigure}[b]{0.4\textwidth}
      \begin{tikzpicture}[framed,->,>=stealth,thick,node distance=45pt]
        \tikzstyle{every state}=[circle,minimum size=20pt,auto]
        \node[initial,state]      (1) {$s$};
        \node[state]     [above right of=1] (2) {$q_1$};
        \node[state]     [below right of=1] (3) {$q_2$};
        \node[state,accepting]     [right=3cm of 1] (4) {$f$};
        \path
        (1) edge [bend left=15] node  [above] {$a$} (2)
        % (2) edge [loop above] node  [above] {$a$} (2)
        (2) edge [bend left=15] node  [right] {$b$} (1)
        (2) edge [bend left=15] node  [right] {$a$} (3)
        (3) edge [loop below] node  [right] {$b$} (3)
        (3) edge [bend left=15] node  [below] {$a$} (1)
        (1) edge [dashed,bend left=15] node  [above] {$a$} (4)
        (2) edge [dashed,bend left=15] node  [above] {$a$} (4)
        (3) edge [dashed,bend right=15] node  [below] {$b$} (4);
        % (1) edge [bend right=15] node [below] {$b$} (3);
      \end{tikzpicture}
    \caption{автомат $\N'$, $\L(\N') = \L(\N)$}
  \end{subfigure}
\end{figure}  
За произволен автомат $\N$, формулирайте точно конструкцията на $\N'$ с едно финално състояние и докажете, че наистина $\L(\N) = \L(\N')$.
Обърнете внимание, че примера показва, че е възможно $\N$ да е детерминиран автомат, но полученият $\N'$ да бъде недетерминиран.
\end{hint}

\begin{problem}
  \marginpar{Нека $\A$, $L = \L(\A)$, е само с едно финално състояние. }
  Докажете, че ако $L$ е автоматен език, то $L^R = \{\omega^R \mid \omega \in L\}$
  също е автоматен.
\end{problem}

\begin{lemma}
  \label{lem:automata-basic}
  Съществува НКА $\N = \NFA$, който разпознава езика $L(r)$, 
  където $r = \emptyset$, $r = \varepsilon$ или $r = a$, за $a\in \Sigma$.
\end{lemma}
\begin{hint}
  \begin{figure}[H]
    \begin{subfigure}[b]{0.2\textwidth}
      \label{subf:a1}
      \begin{tikzpicture}[->,>=stealth,thick,node distance=35pt]
        \tikzstyle{every state}=[circle,minimum size=15pt,auto]
        \node[initial,state]      (1) {$s$};
      \end{tikzpicture}
      \caption{$L(\emptyset)$}
    \end{subfigure}
    \qquad
    \begin{subfigure}[b]{0.2\textwidth}
      \begin{tikzpicture}[->,>=stealth,thick,node distance=35pt]
        \tikzstyle{every state}=[circle,minimum size=15pt,auto]
        \node[initial,state,accepting]      (1) {$s$};
      \end{tikzpicture}
      \caption{$L(\varepsilon)$}
    \end{subfigure}
    \qquad
    \begin{subfigure}[b]{0.3\textwidth}
      \begin{tikzpicture}[->,>=stealth,thick,node distance=35pt]
        \tikzstyle{every state}=[circle,minimum size=15pt,auto]
        \node[initial,state]      (1)              {$s$};
        \node[accepting,state]    (2) [right of=1] {$q$};
        \path 
        (1) edge  node [above] {$a$} (2);
      \end{tikzpicture}
      \caption{$L(a)$}
    \end{subfigure}
  \end{figure}
\end{hint}

\begin{lemma}
  \label{lem:concat}
  Класът на автоматните езици е затворен относно операцията {\em конкатенация}.
  Това означава, че ако $L_1$ и $L_2$ са два произволни автоматни езика, то $L_1\cdot L_2$
  също е автоматен език.
\end{lemma}
\begin{proof}
  Нека са дадени автоматите:
  \begin{itemize}
  \item
    $\N_1 = \NFAn{1}$, като $\L(\N_1) = L_1$;
  \item
    $\N_2 = \NFAn{2}$, като $\L(\N_2) = L_2$.
  \end{itemize}
  Ще дефинираме автомата $\N = \NFA$ като
  \[\L(\N) = L_1\cdot L_2 = \L(\N_1)\cdot\L(\N_2).\]
  \begin{itemize}
  \item
    $Q = Q_1 \cup Q_2$;
  \item
    $s = s_1$;
  \item
    $F = 
    \begin{cases}
      F_1 \cup F_2, & \text{ ако } s_2 \in F_2\\
      F_2,          & \text{ иначе}.
    \end{cases}$
  \item 
    $\Delta(q,a) = 
    \begin{cases}
      \Delta_1(q,a),                      & \text{ ако }q\in Q_1\setminus F_1\ \&\ a\in\Sigma\\
      \Delta_2(q,a),                      & \text{ ако }q\in Q_2\ \&\ a\in\Sigma\\
      \Delta_1(q,a) \cup \Delta_2(s_2,a), & \text{ ако }q \in F_1\ \&\ a\in\Sigma.
    \end{cases}$
  \end{itemize}
\end{proof}

\begin{figure}[H]
  \center
  \begin{subfigure}[b]{0.3\textwidth}
    \label{subf:a1}
    \begin{tikzpicture}[framed,->,>=stealth,thick,node distance=45pt]
      \tikzstyle{every state}=[circle,minimum size=15pt,auto]
      \node[initial,state,accepting]      (1) {$s_1$};
      \node[state]                        (2) [right of=1] {$q_1$};
      \node[state]                        (3) [above right of=2] {$q_2$};
      \node[state,accepting]              (4) [below right of=2] {$q_3$};
      \path
      (1) edge node [above] {$a$} (2)
      (2) edge node [above] {$a$} (3)
      (2) edge node [below] {$b$} (4)
      (3) edge [bend right=30] node [above] {$a$} (1)
      (4) edge [bend left=30] node [below] {$b$} (1);
    \end{tikzpicture}
    \caption{автомат $\N_1$}
  \end{subfigure}
  \qquad
  \qquad
  \qquad
  \begin{subfigure}[b]{0.3\textwidth}
    \begin{tikzpicture}[framed,->,>=stealth,thick,node distance=45pt]
      \tikzstyle{every state}=[circle,minimum size=15pt,auto]
      \node[initial,state]      (1) {$s_2$};
      \node[state]     [above right of=1] (2) {$q_4$};
      \node[state,accepting]     [below right of=1] (3) {$q_5$};
      \path
      (1) edge [bend left=15] node  [above] {$a$} (2)
      (2) edge [bend left=15] node  [right] {$a$} (3)
      (1) edge [bend right=15] node [below] {$b$} (3);
    \end{tikzpicture}
    \caption{автомат $\N_2$}
  \end{subfigure}
\end{figure}

\begin{example}
    За да построим автомат, който разпознава конкатенацията на $\L(\N_1)$ и $\L(\N_2)$,
    трябва да свържем финалните състояния на $\N_1$ с изходящите от $s_2$ състояния на $\N_2$.
    
    \begin{figure}[H]
      \center
      % \begin{subfigure}[b]{0.3\textwidth}
      \begin{tikzpicture}[framed,->,>=stealth,thick,node distance=2cm]
        \tikzstyle{every state}=[circle,minimum size=15pt,auto]
        \node[initial,state]                      (1) {$s_1$};
        \node[state] [right of=1]                 (2) {$q_1$};
        \node[state] [above right of=2]           (3) {$q_2$};
        \node[state] [below right of=2]           (4) {$q_3$};
        \node[state] [right=4cm of 1]             (5) {$s_2$};
        \node[state] [above right of=5]           (6) {$q_4$};
        \node[state,accepting] [below right of=5] (7) {$q_5$};
        \path
        (1) edge node [above]                         {$a$} (2)
        (2) edge node [above]                         {$a$} (3)
        (2) edge node [below]                         {$b$} (4)
        (3) edge [bend right=15] node [above]         {$a$} (1)
        (4) edge [bend left=15] node [below]          {$b$} (1)
        (5) edge [bend left=15] node [below]          {$a$} (6)
        (6) edge [bend left=15] node [right]          {$a$} (7)
        (5) edge [bend right=15] node [above]         {$b$} (7)
        (1) edge [dashed, bend left=45] node [above]  {$a$} (6)
        (1) edge [dashed, bend right=45] node [below] {$b$} (7)
        (4) edge [dashed, bend left=45] node [above]  {$a$} (6)
        (4) edge [dashed, bend left=10] node [above]  {$b$} (7);
      \end{tikzpicture}
      \caption{$\L(\N) = \L(\N_1)\cdot\L(\N_2)$}
  \end{figure}  
  Обърнете внимание, че $\N_1$ и $\N_2$ са детерминирани автомати, но $\N$ е недетерминиран.
  Също така, в този пример се оказва, че вече $s_2$ е недостижимо състояние, но в общия случай не можем да 
  го премахнем, защото може да има преходи влизащи в $s_2$.
\end{example}


\begin{lemma}
  \label{lem:union}
  Класът от автоматните езици е затворен относно операцията {\em обединение}.
\end{lemma}
\begin{hint}
  Нека са дадени автоматите:
  \begin{itemize}
  \item 
    $\N_1 = \NFAn{1}$, като $L(\N_1) = L_1$;
  \item
    $\N_2=\NFAn{2}$, като $L(\N_2) = L_2$.
  \end{itemize}
  Ще дефинираме автомата $\N=\NFA$, така че
  \[L(\N) = L(\N_1) \cup L(\N_2).\]
  \begin{itemize}
  \item 
    $Q = Q_1 \cup Q_2 \cup \{s\}$;
  \item
    $F = 
    \begin{cases}
      F_1 \cup F_2 \cup \{s\}, & \text{ ако } s_1 \in F_1 \vee s_2 \in F_2\\
      F_1 \cup F_2,            & \text{ иначе } 
    \end{cases}$
  \item
    $
    \Delta(q,a) = 
    \begin{cases}
      \Delta_1(q,a),                       & \text{ ако } q\in Q_1\ \&\ a\in\Sigma\\
      \Delta_2(q,a),                       & \text{ ако } q\in Q_2\ \&\  a\in\Sigma\\
      \Delta_1(s_1,a) \cup \Delta_2(s_2,a), & \text{ ако } q = s\ \&\  a \in\Sigma.
    \end{cases}
    $
  \end{itemize}
\end{hint}
\begin{remark}
  В началното състояние на новопостроения автомат $\N$ не влизат ребра.
\end{remark}


\begin{example}
    За да построим автомат, който разпознава обединението на $\L(\N_1)$ и $\L(\N_2)$,
    трябва да свържем финалните състояния на $\N_1$ с изходящите от $s_2$ състояния на $\N_2$.
    
    \begin{figure}[H]
      \center
      % \begin{subfigure}[b]{0.3\textwidth}
      \begin{tikzpicture}[framed,->,>=stealth,thick,node distance=2cm]
        \tikzstyle{every state}=[circle,minimum size=20pt,auto]
        \node[initial,state,accepting]      (0) {$s$};
        \node[state,accepting]    [above right of=0]        (1) {$s_1$};
        \node[state]    [right of=1]        (2) {$q_1$};
        \node[state]                        (3) [above right of=2] {$q_2$};
        \node[state,accepting]                        (4) [below right of=2] {$q_3$};
        \node[state]    [below right=2cm of 0] (5) {$s_2$};
        \node[state]     [above right of=5] (6) {$q_4$};
        \node[state,accepting]     [below right of=5] (7) {$q_5$};
        \path
        (1) edge node [above]                  {$a$} (2)
        (2) edge node [above]                  {$a$} (3)
        (2) edge node [below]                  {$b$} (4)
        (3) edge [bend right=15] node [above]  {$a$} (1)
        (4) edge [bend left=15]  node [below]  {$b$} (1)
        (5) edge [bend left=15] node [below]   {$a$} (6)
        (6) edge [bend left=15] node  [right] {$a$} (7)
        (5) edge [bend right=15] node [above]  {$b$} (7)
        (0) edge [dashed, bend right=15] node [below]  {$a$} (2)
        (0) edge [dashed, bend right=15] node [below]  {$a$} (6)
        (0) edge [dashed, bend right=45] node [below]  {$b$} (7);
      \end{tikzpicture}
      \caption{$\L(\N) = \L(\N_1)\cup\L(\N_2)$}
  \end{figure}  
  Обърнете внимание, че $\N_1$ и $\N_2$ са детерминирани автомати, но $\N$ е недетерминиран.
  Освен това, новото състояние $s$ трябва да бъде маркирано като финално, защото $s_1$ е финално.
\end{example}

\begin{lemma}
  \label{lem:kleene-star}
  Класът от автоматните езици е затворен относно операцията {\em звезда на Клини}, т.е.
  ако $\L(\N) = L$, то съществува $\hat{\N}$, за който $\L(\hat{\N}) = L^\star$.
\end{lemma}
\begin{proof}
  Нека е даден автомата $\N = \NFA$, за който е изпънено, че
  $\L(\N) = \L(\mathbf{r})$.
  Първата стъпка е да построим $\N_1 = \NFAn{1}$, такъв че 
  \[\L(\N_1) = \bigcup_{n\geq 1} (\L(\N))^n = \bigcup_{n\geq 1} (\L(\mathbf{r}))^n = \L(\mathbf{r^+}).\]
  \begin{itemize}
  \item
    $Q_1 = Q$;
  \item
    $s_1 = s$;
  \item
    $F_1 = F$;
  \item
    \marginpar{$\Delta_1$ включва всичко от $\Delta$ като добавя нови преходи към наследниците на началното състояние $s$ на $\N$}
    $\Delta_1(q,a) = 
    \begin{cases}
      \Delta(q,a), & \text{ ако } q\in Q\setminus F, a \in \Sigma\\
      \Delta(q,a) \cup \Delta(s,a), & \text{ ако } q\in F, a\in\Sigma.
    \end{cases}$
  \end{itemize}
  Накрая строим желания автомат $\hat\N$, така че $\L(\hat\N) = \{\varepsilon\} \cup \L(\N_1)$.
  Ние знаем как да построим $\hat\N$, защото можем да посторим автомат $\N_0$ за езика $\{\varepsilon\}$
  (\Lem{automata-basic}) и тогава $\hat\N$ се получава от конструкцията за обединение от \Lem{union} приложена върху $\N_0$ и $\N_1$.
\end{proof}


\begin{example}
  Нека да приложим конструкцията за да намерим автомат разпознаващ $\L(\N)^\star$.
  
  \begin{figure}[H]
    % \center
    \begin{subfigure}[b]{0.3\textwidth}
      \begin{tikzpicture}[framed,->,>=stealth,thick,node distance=45pt]
        \tikzstyle{every state}=[circle,minimum size=20pt,auto]
        \node[initial above,state]      (1) {$s$};
        \node[state]              (2) [right of=1] {$q_1$};
        \node[state,accepting]    (3) [right of=2] {$q_2$};
        \node[state,accepting]    (4) [above of=2] {$q_3$};
        \path
        (1) edge node [above] {$a$} (2)
        (1) edge [bend left=15] node [above] {$b$} (4)
        (2) edge node [above] {$b$} (3)
        (3) edge [bend left=45] node [below] {$a$} (1);
      \end{tikzpicture}
      \caption{автомат $\N$}
    \end{subfigure}
    \hspace{2cm}
    \begin{subfigure}[b]{0.5\textwidth}
      \begin{tikzpicture}[framed,->,>=stealth,thick,node distance=45pt]
        \tikzstyle{every state}=[circle,minimum size=20pt,auto]
        \node[initial above,state,accepting] (0) {$s'$};
        \node[state]                         (1) [below right of=0] {$s$};
        \node[state]                         (2) [right of=1] {$q_1$};
        \node[state,accepting]               (3) [right of=2] {$q_2$};
        \node[state,accepting]               (4) [above of=2] {$q_3$};
        \path
        (0) edge [dashed, bend left=15] node [above] {$a$} (2)
        (0) edge [dashed, bend left=15] node [above] {$b$} (4)
        (1) edge [bend left=15] node [above] {$b$} (4)
        (1) edge node [above] {$a$} (2)
        (2) edge node [below] {$b$} (3)
        (3) edge [bend left=45] node [below] {$a$} (1)
        (3) edge [dashed, bend right=45] node [above] {$b$} (4)
        (4) edge [dashed] node [left] {$a$} (2)
        (4) edge [dashed, loop above] node {$b$} (4)
        (3) edge [dashed, bend right=45] node [above] {$a$} (2);        
      \end{tikzpicture}
      \caption{$\L(\hat\N) = \L(\N)^\star = \L(\N)^+ \cup \{\varepsilon\}$}
    \end{subfigure}
  \end{figure}
    
  \marginpar{Лесно се вижда, че $\L(\N) = \{b\} \cup \{(aba)^nab\mid n\in\Nat\}$}
  След като построим автомат за езика $\L(\N)^+$, трябва да приложим
  конструкцията за обединение на автомата за езика $\L(\N)^+$ с автомата за езика $\{\varepsilon\}$.
  Защо трябва да добавим ново начално състояние $s'$?
  Да допуснем, че вместо това сме направили $s$ финално.
  Тогава има опасност да разпознаем повече думи. Например, думата $aba$ би се разпознала от този автомат,
  но $aba \not\in\L(\N)^\star$.
\end{example}


\section{Лема за покачването}

\begin{lemma}[за покачването]
  \index{лема за покачването!регулярни езици}
  \label{lem:pumping-reg}
  \marginpar{На англ. се нарича \\ Pumping Lemma}
  \marginpar{Има подобна лема и за безконтекстни езици}
  \marginpar{Обърнете внимание, че $0 \in \Nat$ и $xy^0z =  xz$}
  Нека $L$ да бъде {\em безкраен} регулярен език.
  Съществува число $p\geq 1$, зависещо само от $L$, 
  за което за всяка дума $\alpha\in L, \abs{\alpha}\geq p$ може да 
  бъде записана във вида $\alpha = xyz$ и 
  \begin{enumerate}[1)]
  \item
    $|y|\geq 1$;
  \item
    $|xy|\leq p$;
  \item
    $(\forall i\in\Nat)[xy^iz \in L]$.
  \end{enumerate}
\end{lemma}
\begin{hint}
  \marginpar{\cite[стр. 88]{papadimitriou}, \cite[стр. 78]{sipser1}}
  Понеже $L$ е регулярен, то $L$ е и автоматен език. Нека $\A = \FA$ е краен детерминиран 
  автомат, за който $L = \L(\A)$.
  Да положим $p = \abs{Q}$ и нека $\alpha = a_1a_2\cdots a_k$ е дума, за която $k \geq p$.
  Да разгледаме първите $p$ стъпки от изпълнението на $\alpha$ върху $\A$:
  \[s\stackrel{a_1}{\rightarrow} q_1 \stackrel{a_2}{\rightarrow}q_2 \dots \stackrel{a_p}{\rightarrow} q_p.\]
  Тъй като $\abs{Q} = p$, а по този път участват $p+1$ състояния $q_0,q_1,\dots,q_p$,
  то съществуват числа $i, j$, за които $0\leq i < j\leq p$ и $q_i = q_j$.
  Нека разделим думата $\alpha$ на три части по следния начин:
  \[x = a_1\cdots a_i,\quad y = a_{i+1}\cdots a_j,\quad z = a_{j+1}\cdots a_k.\]
  Ясно е, че $\abs{y} \geq 1$ и $\abs{xy} = j \leq p$.
  \marginpar{\ding{45} Докажете!}
  Освен това, лесно се съобразява, че за всяко $i \in\Nat$,
  $xy^iz \in L$. Да разгледаме случая за $i = 0$.
  Думата $xy^0z = xz \in L$, защото имаме следното изчисление:
  \[s\underbrace{\stackrel{a_1}{\rightarrow}q_1 \cdots \stackrel{a_i}{\rightarrow}}_{x} q_i\underbrace{\stackrel{a_{j+1}}{\rightarrow}q_{j+1}\cdots\stackrel{a_{k}}{\rightarrow}}_{z}q_k\in F,\]
  защото $q_i = q_j$.
  Да разгледаме и случая $i = 2$. Тогава думата $xy^2z \in L$, защото имаме следното изчисление:
  \[s\underbrace{\stackrel{a_1}{\rightarrow}q_1 \cdots \stackrel{a_i}{\rightarrow}}_{x} q_i\underbrace{\stackrel{a_{i+1}}{\rightarrow}q_{i+1}\cdots\stackrel{a_{j}}{\rightarrow}}_{y}q_j\underbrace{\stackrel{a_{i+1}}{\rightarrow}q_{i+1}\cdots\stackrel{a_{j}}{\rightarrow}}_{y}q_j\underbrace{\stackrel{a_{j+1}}{\rightarrow}\cdots\stackrel{a_{k}}{\rightarrow}}_{z}q_k\in F.\]
\end{hint}

Практически е по-полезно да разглеждаме следната еквивалентна формулировка на лемата за покачването.
\begin{cor}[Контрапозиция на лемата за покачването]
  \label{cor:pumping-reg}
  \marginpar{Ясно е, че всеки краен език е регулярен. Нали?}
  Нека $L$ е произволен {\em безкраен} език. Нека също така е изпълнено, че за всяко естествено число $p \geq 1$ можем да намерим дума $\alpha \in L$, $\abs{\alpha}\geq p$, такава че за всяко разбиване на думата на три части, $\alpha = xyz$,
  със свойствата $\abs{y} \geq 1$ и $\abs{xy} \leq p$, е изпълнено, че $(\exists i)[xy^iz \not\in L]$.
  Тогава $L$ {\bf не} е регулярен език.
\end{cor}
\begin{proof}
  Да означим с $(P)$ следната предикатна формула:
  {\scriptsize
    \[(\exists p \geq 1)(\forall \alpha \in L)[\abs{\alpha} \geq p \Rightarrow (\exists x,y,z\in\Sigma^\star)[\alpha = xyz\ \wedge\ \abs{y} \geq 1\ \wedge\ \abs{xy} \leq p\ \wedge\ (\forall i\in\Nat)[xy^iz \in L]]].\]}
  \hyperref[lem:pumping-reg]{Лемата за покачването} представлява твърдението:
  
  \begin{center}
  {\em ,,Aко $L$ е регулярен език, то е изпълнено свойството $(P)$.''}
  \end{center}
  \marginpar{Контрапозиция на твърдението $p \to q$ е твърдението $\neg q \to \neg p$}
  \noindent
  Лемата може да се запише по следния еквивалентен начин:
  
  \begin{center}
    {\em ,,Ако свойството $(P)$ не е изпълнено, то $L$ не е регулярен език.''}
  \end{center}

  \marginpar{Използваме, че $\neg \exists \forall \exists \forall (\dots) \equiv \forall \exists \forall \exists \neg(\dots)$}

  \noindent Отрицанието на свойството $(P)$ може да се запише по следния начин:
  {\scriptsize  \[(\forall p \geq 1)(\exists \alpha \in L)[\abs{\alpha} \geq p\ \wedge (\forall x,y,z\in\Sigma^\star)[\alpha \neq xyz\ \vee\ \abs{y} \not\geq 1\ \vee\ \abs{xy} \not\leq p\ \vee\ (\exists i\in\Nat)[xy^iz \not\in L]]].\]}
  Горната формула е еквивалентна на:
  \marginpar{Използваме, че $\neg p \vee \neg q \vee r \equiv (p \wedge q) \to r$}
  {\scriptsize
    \[(\forall p \geq 1)(\exists \alpha \in L)[\abs{\alpha} \geq p\ \wedge\ (\forall x,y,z\in\Sigma^\star)[(\alpha = xyz \wedge \abs{y} \geq 1\wedge \abs{xy} \leq p) \Rightarrow (\exists i\in\Nat)[xy^iz \not\in L]]].\]}
\end{proof}

\subsection*{Приложения на лемата за покачването}

\begin{problem}
  Докажете, че езикът $L = \{a^nb^n \mid n\in \Nat\}$ не е регулярен.
\end{problem}
\begin{proof}
  \marginpar{Това е важен пример. По-късно ще видим, че този език е безконтекстен}
  Ще докажем, че
  {\scriptsize
    \[(\forall p \geq 1)(\exists \alpha \in L)[\abs{\alpha} \geq p\ \wedge\ (\forall x,y,z\in\Sigma^\star)[(\alpha = xyz \wedge \abs{y} \geq 1\wedge \abs{xy} \leq p) \Rightarrow (\exists i\in\Nat)[xy^iz \not\in L]].\]}
  Доказателството следва стъпките:
  \begin{itemize}
  \item 
    Разглеждаме произволно число $p \geq 1$ (нямаме власт над избора на $p$).
  \item
    \marginpar{Няма общо правило, което да ни казва как избираме думата $\alpha$. Нормално е да пробаваме с няколко думи, докато намерим такава, която върши работа.}
    Избираме дума $\alpha \in L$, за която $\abs{\alpha} \geq p$. Имаме свободата да изберем каквато дума $\alpha$
    си харесаме, стига тя да принадлежи на $L$ и да има дължина поне $p$.
    \marginpar{Обърнете внимание, че думата $\alpha$ зависи от константата $p$}
    Щом имаме тази свобода, нека да изберем думата $\alpha = a^pb^p \in L$.
    Очевидно е, че $\abs{\alpha} \geq p$.
  \item
    Разглеждаме произволно разбиване на $\alpha$ на три части, $\alpha = xyz$,
    за които изискваме свойствата $\abs{xy} \leq p$ и $\abs{y} \geq 1$ (не знаем нищо друго за $x$, $y$ и $z$ освен тези две свойства).
  \item
    Ще намерим $i\in\Nat$, за което $xy^iz \not\in L$.
    Понеже $\abs{xy} \leq p$, то $y = a^k$, за  $1\leq k \leq p$.
    Тогава ако вземем $i = 0$, получаваме $xy^0z = a^{p-k}b^p$.
    Ясно е, че $xz \not\in L$, защото $p-k < p$.
  \end{itemize}  
  Тогава от \Cor{pumping-reg} следва, че $L$ не е регулярен език.
\end{proof}

\begin{remark}
  Много често студентите правят следното разсъждение:
  \[(\forall L,L' \subseteq \Sigma^\star)[L \text{ е регулярен}\ \&\ L' \subseteq L \implies L'\text{ е регулярен}].\]
  Съобразете, че в общия случай това твърдение е невярно.
  За да видите това, достатъчно е да посочите регулярен език $L$, който има като
  подмножество нерегулярен език $L'$.
  Също лесно се вижда, че твърдението
  \[(\forall L,L' \subseteq \Sigma^\star)[L \text{ е регулярен}\ \&\ L \subseteq L' \implies L'\text{ е регулярен}]\]
  е невярно.
\end{remark}


\begin{problem}
  Докажете, че езикът $L = \{a^mb^n \mid m,n\in \Nat\ \&\ m < n\}$ не е регулярен.
\end{problem}
\begin{proof}
  Доказателството следва стъпките:
  \begin{itemize}
  \item 
    Разглеждаме произволно число $p \geq 1$.
  \item
    Избираме дума $\alpha \in L$, за която $\abs{\alpha} \geq p$. Имаме свободата да изберем каквато дума $\alpha$
    си харесаме, стига тя да принадлежи на $L$ и да има дължина поне $p$.
    Щом имаме тази свобода, нека да изберем думата $\alpha = a^{p}b^{p+1} \in L$. Очевидно е, че $\abs{\alpha} \geq p$.
  \item
    Разглеждаме произволно разбиване на $\alpha$ на три части, $\alpha = xyz$,
    за които изискваме свойствата $\abs{xy} \leq p$ и $\abs{y} \geq 1$ (не знаем нищо друго за $x$, $y$ и $z$ освен тези две свойства).
  \item
    Ще намерим $i\in\Nat$, за което $xy^iz \not\in L$.
    Понеже $\abs{xy} \leq p$, то $y = a^k$, за  $1\leq k \leq p$.
    Тогава ако вземем $i = 2$, получаваме 
    \[xy^2z = a^{p-k}a^{2k}b^{p+1} = a^{p+k}b^{p+1}.\]
    Ясно е, че $xy^2z \not\in L$, защото $p+k \geq p+1$.
  \end{itemize}
  Тогава от \Cor{pumping-reg} следва, че $L$ не е регулярен език.
\end{proof}

\begin{problem}
  Докажете, че езикът $L = \{a^n\ \mid\ n\mbox{ е просто число}\}$ не е регулярен.
\end{problem}
\begin{proof}
  Доказателството следва стъпките:
  \begin{itemize}
  \item 
    Разглеждаме произволно число $p \geq 1$.
  \item
    Избираме дума $w \in L$, за която $\abs{w} \geq p$. Можем да изберем каквото $w$ 
    си харесаме, стига то да принадлежи на $L$ и да има дължина поне $p$.
    Нека да изберем думата $w \in L$, такава че $\abs{w} > p+1$.
    Знаем, че такава дума съществува, защото $L$ е безкраен език. По-долу ще видим защо този избор е важен за нашите разсъждения.
  \item
    Разглеждаме произволно разбиване на $w$ на три части, $w = xyz$,
    за които изискваме свойствата $\abs{xy} \leq p$ и $\abs{y} \geq 1$.
  \item
    Ще намерим $i$, за което $xy^iz \not\in L$,
    т.е. ще намерим $i$, за което 
    $\abs{xy^iz} = \abs{xz} + i\cdot\abs{y}$ е {\em съставно число}.
    Понеже $\abs{xy} \leq p$ и $\abs{xyz} > p+1$, то $\abs{z} > 1$.
    Да изберем $i = \abs{xz} > 1$. Тогава:
    \[\abs{xy^iz} = \abs{xz} + i.\abs{y} = \abs{xz} + \abs{xz}.\abs{y} = (1 + \abs{y})\abs{xz}\] е съставно число, следователно 
    $xy^iz \not\in L$.
  \end{itemize}
  Тогава от \Cor{pumping-reg} следва, че $L$ не е регулярен език.
\end{proof}

\begin{problem}
  Докажете, че езикът $L = \{a^{n^2}\ \mid\ n\in\Nat\}$ не е регулярен.  
\end{problem}
\begin{proof}
  В тази задача ще използваме следното свойство:
  \[n\text{ не е точен квадрат} \iff (\exists p\in \Nat)[p^2 < n < (p+1)^2].\]
  Доказателството следва стъпките:
  \begin{itemize}
  \item 
    Разглеждаме произволно число $p \geq 1$.
  \item
    Избираме достатъчно дълга дума, която принадлежи на езика $L$.
    Например, нека $w = a^{p^2}$.
  \item
    Разглеждаме произволно разбиване на $w$ на три части, $w = xyz$, 
    като $\abs{xy} \leq p$ и $\abs{y} \geq 1$.
  \item
    Ще намерим $i$, за което $xy^iz \not\in L$.
    В нашия случай това означава, че $\abs{xz} + i\cdot\abs{y}$ не е точен квадрат.
    Тогава за $i = 2$,
    \[p^2 = \abs{xyz} < \abs{xy^2z} = \abs{xz} + 2\abs{y} \leq p^2 + 2p < p^2 + 2p + 1 = (p+1)^2 .\]
    Получаваме, че $p^2 < \abs{xy^2z} < (p+1)^2$,
    откъдето следва, че $\abs{xy^2z}$ не е точен квадрат.
    Следователно, $xy^2z \not\in L$.
  \end{itemize}
  Тогава от \Cor{pumping-reg} следва, че $L$ не е регулярен език.  
\end{proof}

\begin{problem}
  Докажете, че езикът $L = \{a^{n!}\ \mid\ n\in\Nat\}$ не е регулярен.  
\end{problem}
\begin{proof}
  Доказателството следва стъпките:
  \begin{itemize}
  \item 
    Разглеждаме произволно число $p \geq 1$.
  \item
    Избираме достатъчно дълга дума, която принадлежи на езика $L$. Например, нека $\omega = a^{(p+2)!}$.
  \item
    Разглеждаме произволно разбиване на $\omega$ на три части, $\omega = xyz$, 
    като $\abs{xy} \leq p$ и $\abs{y} \geq 1$.
    Да обърнем внимание, че $1 \leq \abs{y} \leq p$
  \item
    Ще намерим $i$, за което $xy^iz \not\in L$.
    В нашия случай това означава, че $\abs{xz} + i\cdot\abs{y}$ не е от вида $n!$.
    Възможно ли е $xy^0z \in L$?
    Понеже $\abs{xyz} = (p+2)!$, това означава, че $\abs{xz} = k!$, за някое $k \leq p+1$.
    Тогава 
    \[\abs{y} = \abs{xyz} - \abs{xz} = (p+2)! - k! \geq (p+2)! - (p+1)! = (p+1).(p+1)! > p.\]
    Достигнахме до противоречие с условието, че $\abs{y} \leq p$.
  \end{itemize}
  Тогава от \Cor{pumping-reg} следва, че $L$ не е регулярен език.  
\end{proof}

\subsection*{Следствия от лемата за покачването}

\begin{prop}
  Нека е даден автомата $\A = \FA$.
  Езикът $\L(\A)$ е {\em непразен} е точно тогава, когато съдържа дума $\alpha, \abs{\alpha} < \abs{Q}$.
\end{prop}
\begin{proof}
  Ще разгледаме двете посоки на твърдението.
  \begin{description}
  \item[$(\Rightarrow)$]
    Нека $L$ е непразен език и нека $m = \min\{\abs{\alpha} \mid \alpha \in L\}$.
    Ще докажем, че $m < \abs{Q}$.    
    За целта, да допуснем, че $m \geq \abs{Q}$ и да изберем $\alpha \in L$, за която $\abs{\alpha} = m$.
    Според \Lem{pumping-reg}, съществува разбиване $xyz = \alpha$, 
    такова че $xz \in L$.
    При положение, че $\abs{y} \geq 1$, то $\abs{xz} < m$, което 
    е противоречие с минималността на $m$.
    Заключаваме, че нашето допускане е грешно. Тогава $m < \abs{Q}$, откъдето следва, че 
    съществува дума $\alpha \in L$ с $\abs{\alpha} < \abs{Q}$.
  \item[$(\Leftarrow)$]
    Тази посока е тривиална.
    Ако $L$ съдържа дума $\alpha$, за която $\abs{\alpha} < \abs{Q}$,
    то е очевидно, че $L$ е непразен език.
  \end{description}
\end{proof}

\begin{cor}
  Съществува алгоритъм, който проверява дали даден регулярен език е празен или не.
\end{cor}


\begin{cor}
  \marginpar{$(L_1\setminus L_2) \cup (L_2 \setminus L_1) = \emptyset$?}
  Съществува алгоритъм, който определя дали два автомата $\A_1$ и $\A_2$ разпознават един и същ език.
\end{cor}

\begin{prop}
  Регулярният език $L$, 
  разпознаван от КДА $\A$, е {\em безкраен} точно тогава, когато съдържа дума $\alpha, \abs{Q} \leq \abs{\alpha} < 2\abs{Q}$.
\end{prop}
\begin{proof}
  Да разгледаме двете посоки на твърдението.
  \begin{description}
  \item[$(\Leftarrow)$]
    Нека $L$ е регулярен език, за който съществува дума $\alpha$, такава че $\abs{Q} \leq \abs{\alpha} < 2\abs{Q}$.
    Тогава от \Lem{pumping-reg} следва, че съществува разбиване $\alpha = xyz$ със свойството, че
    за всяко $i \in \Nat$, $xy^iz \in L$. Следователно, $L$ е безкраен, защото $\abs{y} \geq 1$.
  \item[$(\Rightarrow)$]
    Нека $L$ е безкраен език и % да приемем, че няма думи $\alpha$ със
    % свойството $\abs{Q} \leq \abs{\alpha} <  2\abs{Q}$.
    да вземем {\em най-късата} дума $\alpha \in L$, за която $\abs{\alpha} \geq 2\abs{Q}$.
    Понеже $L$ е безкраен, знаем, че такава дума съществува.
    Тогава отново по \Lem{pumping-reg}, имаме следното разбиване на $\alpha$:
    \[\alpha = xyz,\ \abs{xy} \leq \abs{Q},\ 1\leq \abs{y},\ xz \in L.\]
    Но понеже $\abs{xyz} \geq 2\abs{Q}$, а $1 \leq \abs{y} \leq \abs{Q}$, то $\abs{xyz} > \abs{xz} \geq \abs{Q}$ и понеже избрахме $\alpha = xyz$
    да бъде най-късата дума с дължина поне $2\abs{Q}$, заключаваме, че $\abs{Q} \leq \abs{xz} < 2\abs{Q}$ и $xz \in L$.
  \end{description}
\end{proof}

\begin{cor}
  Съществува алгоритъм, който проверява дали даден регулярен език е безкраен.
\end{cor}


\subsection*{Примери, за които лемата не е  приложима}

\begin{problem}
  \marginpar{Например, $c^+\{a^nb^n\mid n\in\Nat\}\cup (a + b)^\star$}
  Да се даде пример за език $L$, който {\bf не} е регулярен, но удовлетворява
  условието на \Lem{pumping-reg}.
\end{problem}

\begin{example}
  Езикът $L = \{c^ka^nb^m\mid k,n,m \in \Nat\ \&\ k = 1\implies m = n\}$
  {\bf не} е регулярен, но условието за покачване от \Lem{pumping-reg} е изпълнено за него.
\end{example}
\begin{proof}
  Да допуснем, че $L$ е регулярен.
  Тогава ще следва, че 
  \[L_1 = L\cap ca^\star b^\star = \{ca^nb^n \mid n\in\Nat\}\]
  е регулярен,
  но с лемата за разрастването лесно се вижда, че $L_1$ не е.

  Сега да проверим, че условието за покачване от \Lem{pumping-reg} е изпълнено за $L$.
  Да изберем константа $p = 2$.
  Сега трябва да разгледаме всички думи $\alpha \in L$, $\abs{\alpha} \geq 2$
  и за всяка $\alpha$ да посочим разбиване $xyz = \alpha$, за което са изпълнени трите свойства от лемата.
  \marginpar{Условията за $x,y,z$ са:
    \begin{align*}
      & \abs{xy} \leq 2\\
      & \abs{y} \geq 1\\
      & (\forall i\in\Nat)(xy^iz \in L)
    \end{align*}}

  \begin{itemize}
  \item
    Ако $\alpha = a^n$ или $\alpha = b^n$, $n\geq 2$, то е  очевидно, че можем да
    намерим такова разбиване.
  \item
    $\alpha = a^nb^m$ и $n+m \geq 2$, $n \geq 1$.
    Избираме $x = \varepsilon$, $y = a$, $z = a^{n-1}b^m$.
  \item
    $\alpha = ca^nb^n$, $n\geq 1$.
    Избираме $x = \varepsilon$, $y = c$, $z = a^nb^n$.
  \item
    $\alpha = c^2a^nb^m$. 
    Избираме $x = \varepsilon$, $y = c^2$, $z = a^nb^m$.
  \item
    $\alpha = c^ka^nb^m$, $k \geq 3$.
    Избираме $x = \varepsilon$, $y = c$, $z = c^{k-1}a^nb^m$.
  \end{itemize}
\end{proof}

\section{Минимлен автомат}

\subsection{Минимален автомат по даден регулярен език}
Нека $\alpha$ е дума над азбуката $\Sigma$  и $L$ е език. Означаваме 
\[\alpha^{-1}L = \{\omega \in \Sigma^\star \mid \alpha\omega \in L\}.\]
Освен това, да означим 
\[\alpha L = \{\alpha\omega \in \Sigma^\star \mid \omega \in L\}.\]
Имаме свойството, че
\[L = \{\omega \in \Sigma^\star \mid \varepsilon \in \omega^{-1}L\}.\]

Да разгледаме езика $L = \L(\mathbf{((a+b)^+\cdot a)^\star})$.
Да видим как можем директно да построим минимален тотален детерминиран автомат $\A = \pair{Q^\A,\Sigma,s,\delta_\A,F^\A}$ разпознаващ $L$.
Състоянията на автомата ще бъдат от вида $q_B$, където $B \subseteq \Sigma^\star$, така че
\[B = \{\omega \in \Sigma^\star \mid \delta^\star_\A(q_B,\omega) \in F^\A\}.\]
Тогава началното състояние $s$ ще бъде $q_L$, защото 
\[L = \L(\A) = \{\omega \in \Sigma^\star \mid \delta^\star_\A(q_L,\omega) \in F^\A\}.\]
Сега едновременно ще строим състоянията на автомата $Q^\A$ и функцията на преходите $\delta_\A$.
\begin{itemize}
\item 
  $a^{-1}L = aL \cup \{a,b\}^+aL \df M$.
  Понеже $M \neq L$, имаме ново състояние $q_M$ в автомата и 
  $\delta_\A(q_L,a) = q_M$.
\item
  $b^{-1}L = aL\cup \{a,b\}^+aL = M$;
  Следователно, $\delta_\A(q_L,b) = q_M$.
\item
  $a^{-1}M = L \cup aL \cup \{a,b\}^+aL \df N$. Понеже $N \neq L, M$, имаме ново състояние $q_N$ в автомата и 
  $\delta_\A(q_M,a) = q_N$.
\item
  $b^{-1}M = aL\cup \{a,b\}^+aL = M$. Следователно, $\delta_\A(q_M,b) = q_M$.
\item
  $a^{-1}N = a^{-1}L \cup L \cup aL \cup \{a,b\}^+aL = N$. Следователно, $\delta_\A(q_N,a) = q_N$.
\item
  $b^{-1}N = aL \cup \{a,b\}^+aL = M$.
  Следователно, $\delta_\A(q_M,b) = q_M$.
\end{itemize}
Така получихме, че 
\[Q^\A = \{q_L, q_N, q_M\}.\]
Нека сега да съобразим кои са финалните състояния.
Понеже искаме нашия автомат да има свойството, че
\[B = \{\omega \in \Sigma^\star \mid \delta^\star(q_B,\omega) \in F^\A\},\]
то $q_B \in F^\A \iff \delta^\star_\A(q_B,\varepsilon) \in F^\A \iff \varepsilon \in B$.
Следователно, в нашия автомат, финалните състояния са $q_L$ и $q_M$,
защото $\varepsilon \in L,M$. 
Сега вече сме готови да нарисуваме картинка на автомата.

\begin{figure}[H]
  \begin{subfigure}[b]{.4\textwidth}
    \begin{tikzpicture}[->,>=stealth,thick,node distance=55pt]
      \tikzstyle{every state}=[circle,minimum size=20pt,auto]
      
      \node[initial above, state,accepting]   (L) {$q_L$};
      \node[state]                            (M) [right of=L]{$q_M$};
      \node[state,accepting]                  (N) [right of=M]{$q_N$};
      
      
      \path 
      (L) edge [bend left=15] node [above] {$a,b$}   (M)
      (M) edge [loop above] node [above] {$b$} (M)
      (M) edge [bend left=15] node [above] {$a$} (N)
      (N) edge [bend left=15] node [below] {$b$} (M)
      (N) edge [loop above] node [above] {$a$} (N);
    \end{tikzpicture}
    \caption{Минимален автомат за езика $\L(\mathbf{((a+b)^+a)^\star})$}
  \end{subfigure}
  \quad
  ~
  \quad
  \begin{subfigure}[b]{.4\textwidth}
    \begin{tikzpicture}[->,>=stealth,thick,node distance=55pt]
      \tikzstyle{every state}=[circle,minimum size=20pt,auto]
      
      \node[initial above, state,accepting]   (L) {$[\varepsilon]_L$};
      \node[state]                            (M) [right of=L]{$[a]_L$};
      \node[state,accepting]                  (N) [right of=M]{$[aa]_L$};
      
      
      \path 
      (L) edge [bend left=15] node [above] {$a,b$}   (M)
      (M) edge [loop above] node [above] {$b$} (M)
      (M) edge [bend left=15] node [above] {$a$} (N)
      (N) edge [bend left=15] node [below] {$b$} (M)
      (N) edge [loop above] node [above] {$a$} (N);
    \end{tikzpicture}
    \caption{Минимален автомат за езика $\L(\mathbf{((a+b)^+a)^\star})$}
  \end{subfigure}
\end{figure}

Остава да се уверим, че нашата конструкция е коректна, т.е. наистина автоматът $\A$ е минимален за езика $L$.
Според \Th{myhill-nerode}, състоянията на минималния автомат $\M$ са класовете на еквивалентност на релацията $\approx_L$.
Трябва да построим биекция $f:Q^\A \to Q^\M$, така че
\[(\forall q\in Q^\A)(\forall x\in \Sigma)[f(\delta_\A(q,x)) = \delta_\M(f(q),x)].\]
В нашия случай, $Q^\A = \{q_L,q_M,q_N\}$.
\begin{itemize}
\item 
  Ясно е, че $f(q_L) \df [\varepsilon]_L$ защото това са началните състояния.
\item
  Понеже $\delta_\A(q_L,a) = q_M$ и $\delta_\M([\varepsilon]_L,a) = [a]_L$, то $f(q_M) = [a]_L$. Ясно е, че $[\varepsilon]_L \neq [a]_L$
  и следователно $f$ продължава да е инективна.
\item
  Понеже $\delta_\A(q_L,b) = q_M$ и $\delta_\M([\varepsilon]_L,b) = [b]_L$, то $f(q_M) = [b]_L$. Лесно се вижда, че наистина $[a]_L = [b]_L$
  и следователно дефиницията на $f$ е коректна.
\item
  Понеже $\delta_\A(q_M,a) = q_N$ и $\delta_\M([a]_L,a) = [aa]_L$, то $f(q_N) = [aa]_L$. Лесно се вижда, че $[aa]_L \neq [\varepsilon]_L$
  и $[aa]_L \neq [a]_L$. Това означава, че $f$ продължава да е инективна.
\item
  Понеже $\delta_\A(q_M,b) = q_M$ и $\delta_\M([a]_L,b) = [ab]_L$, то $f(q_M) = [ab]_L$. Лесно се вижда, че $[a]_L = [ab]_L$.
\item
  Понеже $\delta_\A(q_N,a) = q_N$ и $\delta_\M([aa]_L,a) = [aaa]_L$, то $f(q_N) = [aaa]_L$. Лесно се вижда, че $[aaa]_L = [aa]_L$, т.е.
  $f$ продължава да бъде коректно дефинирана функция.
\item
  Понеже $\delta_\A(q_N,b) = q_M$ и $\delta_\M([aa]_L,b) = [aab]_L$, то $f(q_M) = [aab]_L$. Лесно се вижда, че $[aab]_L = [ab]_L$, т.е.
  $f$ продължава да бъде коректно дефинирана функция.
\end{itemize}
Според горните разсъждения, 
\begin{align*}
  Q^\M & = \{f(q_L),f(q_M),f(q_N)\} = \{[\varepsilon]_L, [a]_L, [aa]_L\},\\
  F^\M & = \{f(q_L), f(q_N)\} = \{[\varepsilon]_L, [aa]_L\}.
\end{align*}

Проверете, че наистина $L = [\varepsilon]_L \cup [aa]_L$.

\begin{example}
  Да разгледаме езика $L = \L(\mathbf{a\cdot(a+b)^\star\cdot b})$.
  \begin{itemize}
  \item 
    $a^{-1}L = \{a,b\}^\star b = M$;
  \item
    $b^{-1}L = \emptyset$;
  \item
    $a^{-1}M = \{b\} \cup \{a,b\}^\star b = N$;
  \item
    $b^{-1}M = \{\varepsilon\} \cup \{b\} \cup \{a,b\}^\star b = P$;
  \item
    $a^{-1}N = \{b\} \cup \{a,b\}^\star b = M$;
  \item
    $b^{-1}N = \{\varepsilon\} \cup \{b\} \cup \{a,b\}^\star b = P$;
  \item
    $a^{-1}P = \{b\} \cup \{a,b\}^\star b = N$;
  \item
    $b^{-1}P = \{\varepsilon\} \cup \{b\} \cup \{a,b\}^\star b = P$.
  \end{itemize}

  \begin{figure}[H]
    \centering
    \begin{tikzpicture}[->,>=stealth,thick,node distance=55pt]
      \tikzstyle{every state}=[circle,minimum size=20pt,auto]
      
      \node[initial, state]                   (L) {$q_L$};
      \node[state]                            (M) [above right of=L]{$q_M$};
      \node[state]                            (E) [below right of=L]{$q_\emptyset$};
      \node[state]                            (N) [right of=M]{$q_N$};
      \node[state, accepting]                 (P) [below of=N]{$q_P$};
      
      
      \path 
      (L) edge [bend left=15]  node [above] {$a$} (M)
      (L) edge [bend right=15] node [above] {$b$} (E)
      (E) edge [loop right]    node [right] {$a,b$} (E) 
      (M) edge [bend right=15] node [below] {$a$} (N)
      (N) edge [bend right=30] node [above] {$a$} (M)
      (M) edge [bend right=15] node [below] {$b$} (P)
      (N) edge [bend left=15]  node [right] {$b$} (P)
      (P) edge [bend left=15]  node [left]  {$a$} (N)
      (P) edge [loop right]    node [right] {$b$} (P);      
    \end{tikzpicture}
    \caption{Минимален автомат за $\L(\mathbf{a\cdot (a+b)^\star\cdot b})$}
  \end{figure}  
\end{example}

\begin{example}
  Да разгледаме езика $L = \{a^nb^n\mid n \in \Nat\}$. Да се опитаме да построим автомат, който го разпознава.
  Нека да означим $L_k = \{a^nb^{n+k}\mid n \in \Nat\}$. Да видим какво се получава като приложим процедурата за строене 
  на минимален автомат.
  \begin{itemize}
  \item 
    $a^{-1}L = L_1$;
  \item
    $b^{-1}L = \emptyset$;
  \item
    $a^{-1}L_1 = L_2$;
  \item
    $b^{-1}L_1 = \{\varepsilon\}$;
  \item
    $a^{-1}\{\varepsilon\} = b^{-1}\{\varepsilon\} = \emptyset$;
  \item
    Вижда се, че $a^{-1}L_k = L_{k+1}$, за всяко $k$.
  \item
    Вижда се, че $b^{-1}L_{k+1} = \{b^k\}$, за всяко $k$.
    Освен това е ясно, че $b^{-1}\{b^{k}\} = \{b^{k-1}\}$, за всяко $k \geq 1$.
  \end{itemize}
  Получаваме, че езикът $L$ се разпознава от автомат с {\em безкрайно много състояния}.
  
  \begin{figure}[H]
    \centering
    \begin{tikzpicture}[->,>=stealth,thick,node distance=55pt]
      \tikzstyle{every state}=[circle,minimum size=15pt,auto]
      
      \node[initial, state]                   (0) {$L$};
      \node[state]                            (1) [right of=0]{$L_1$};
      \node[state]                            (2) [right of=1]{$L_2$};
      \node[state]                            (3) [right of=2]{$L_3$};
      \node[state]                            (E) [below of=1]{$\emptyset$};
      \node[state]                            (B) [below right of=1]{$\{b\}$};
      \node[state]                            (BB) [below right of=2]{$\{bb\}$};
      \node[state, accepting]                 (A) [below of=B]{$\{\varepsilon\}$};
      
      \coordinate[right of=3] (4);
      \coordinate[below right of=3] (BBB); 
      \coordinate[below of=4] (BBBA); 

      \path 
      (0) edge [bend left=15]  node [above] {$a$} (1)
      (1) edge [bend left=15]  node [above] {$a$} (2)
      (2) edge [bend left=15]  node [above] {$a$} (3)
      (0) edge [bend right=15]  node [above] {$b$} (E)
      (E) edge [loop left]    node [left] {$a,b$} (E)
      (1) edge [bend right=15]  node [left] {$b$} (E)
      (2) edge [bend right=15]  node [left] {$b$} (B)
      (3) edge [bend right=15]  node [left] {$b$} (BB)
      (B) edge [bend right=15]  node [left] {$b$} (A)
      (B) edge [bend right=15]  node [above] {$a$} (E)
      (A) edge [bend left=15]  node [left] {$a,b$} (E)
      (BB) edge [bend right=15]  node [above] {$b$} (B)
      (BB) edge [bend left=15]  node [below] {$a$} (E);
      
      \draw [dashed,->,shorten >=0pt] (3) to[bend left=15] node[auto] {$a$} (4);
      \draw [dashed,->,shorten >=0pt] (BBB) to[bend right=15] node[above] {$b$} (BB);
      \draw [dashed,->,shorten >=0pt] (BBBA) to[bend left=30] node[below] {$a$} (E);
    \end{tikzpicture}
    \caption{Получаваме {\em безкраен} автомат за $\{a^nb^n \mid n \in \Nat\}$}
  \end{figure}    
\end{example}



\subsection{Проверка за регулярност на език}

\begin{framed}
  \begin{prop}
    Езикът $L$ е регулярен точно тогава, когато релацията $\approx_L$ има {\em крайно много} класове на еквивалентност.
  \end{prop}
\end{framed}
\begin{proof}
  Ако $L$ е регулярен, то той се разпознава от някой ДКА $\A$, който има крайно много състояния 
  и следователно крайно много класове на еквивалентност относно $\sim_\A$.
  Релацията $\approx_L$ е по-груба от $\sim_\A$ и има по-малко класове на еквивалентност.
  Следователно, $\approx_L$ има крайно много класове на еквивалентност.
  
  За другата посока, ако $\approx_L$ има крайно много класове на еквивалентност, то можем да 
  построим ДКА $\A$ както в доказателството на \Th{myhill-nerode}, който разпознава $L$.
\end{proof}

Това следствие ни дава още един начин за проверка дали даден език е регулярен.
За разлика от \Lem{pumping-reg}, сега имаме {\bf необходимо и достатъчно условие}.
При даден език $L$, ние разглеждаме неговата релация $\approx_L$.
Ако тя има крайно много класове, то езикът $L$ е регулярен.
В противен случай, езикът $L$ не е регулярен.

\begin{example}
  За езика $L = \{a^nb^n\mid n \in \Nat\}$ имаме, че $\abs{\approx_L} = \infty$,
  защото \[(\forall k,j\in\Nat)[k \neq j \implies [a^kb]_L \neq [a^jb]_L].\]
  Проверете, че $[a^kb]_L = \{a^kb,a^{k+1}b^{2},\dots,a^{k+l}b^{l+1},\dots\}$.
  Така получаваме, че релацията $\approx_L$ има безкрайно много класове на еквивалентност.
  Заключаваме, че този език {\bf не} е регулярен.
\end{example}

\begin{example}
  За езика $L = \{a^{n^2} \mid n \in \Nat\}$ имаме, че $\abs{\approx_L} = \infty$,
  защото \[(\forall m,n\in\Nat)[m \neq n \implies [a^{n^2}]_L \neq [a^{m^2}]_L].\]
  
  Без ограничение на общността, да разгледаме $n < m$ и думата $\gamma = a^{2n+1}$.
  Тогава $a^{n^2}\gamma = a^{(n+1)^2} \in L$, но 
  $m^2 < m^2 + 2n + 1 < (m+1)^2$ и следователно $a^{m^2}\gamma = a^{m^2+2n+1}\not\in L$.
\end{example}

\begin{example}
  За езика $L = \{a^{n!} \mid n \in \Nat\}$ имаме, че $\abs{\approx_L} = \infty$,
  защото \[(\forall m,n\in\Nat)[m \neq n \implies [a^{n!}]_L \neq [a^{m!}]_L].\]
  
  Без ограничение на общността, да разгледаме $n < m$ и думата $\gamma = a^{(n!)n}$.
  Тогава $a^{n!}\gamma = a^{(n+1)!} \in L$, но 
  $m! < m! + (n!)n < m! + (m!)m = (m+1)!$ и следователно $a^{m!}\gamma = a^{m!+(n!)n}\not\in L$.
\end{example}

\begin{problem}
  Да разгледаме езика
  \[L = \{a^{f_n} \mid f_0 = f_1 = 1\ \&\ f_{n+2} = f_{n+1} + f_{n}\}.\]
  Докажете, че $\abs{\approx_L} = \infty$.
\end{problem}

%\marginpar{\href{http://en.wikipedia.org/wiki/DFA_minimization}{Уикипедия}}

\begin{itemize}
\item
  \index{Майхил-Нероуд!релация}
  \marginpar{$\approx_L$ е известна като релация на Майхил-Нероуд}
  Нека $L \subseteq \Sigma^\star$ е език и нека $x,y \in \Sigma^\star$.
  Казваме, че $x$ и $y$ са {\bf еквивалентни относно} $L$, което записваме 
  като $\alpha \approx_L \beta$, ако е изпълнено:
  \[(\forall \omega \in \Sigma^\star)[\alpha\omega \in L \iff \beta\omega \in L].\]
  С други думи, 
  \[\alpha \approx_L \beta \iff \alpha^{-1}L = \beta^{-1}L.\]
\item
  \marginpar{Трябва ли $\A$ да е тотален?}
  Нека $\A = \FA$ е ДКА.
  Казваме, че две думи $\alpha,\beta \in \Sigma^\star$ са {\bf еквивалентни относно $\A$},
  което означаваме с $\alpha \sim_\A \beta$, ако 
  \[\delta^\star(s,\alpha) = \delta^\star(s,\beta).\]
\item
  Проверете, че $\approx_L$ и $\sim_\A$ са {\bf релации на еквивалентност}, т.е.
  те са рефлексивни, транзитивни и симетрични.
\item
  Класът на еквивалентност на думата $\alpha$ относно релацията $\approx_L$ означаваме като
  \[[\alpha]_L = \{\beta \in \Sigma^\star \mid \alpha \approx_L \beta\}.\]
  С $\abs{\approx_L}$ ще означаваме броя на класовете на еквивалентност на релацията $\approx_L$.
\item
  Класът на еквивалентност на думата $\alpha$ относно релацията $\sim_\A$ означаваме като
  \[[\alpha]_\A = \{\beta \in \Sigma^\star \mid \alpha \sim_\A \beta\}.\]
  С $\abs{\sim_\A}$ ще означаваме броя на класовете на еквивалентност на релацията $\sim_\A$.
\item
  Съобразете, че всяко състояние на $\A$, което е достижимо от началното състояние, определя клас на еквивалентност относно 
  релацията $\sim_\A$. Това означава, че ако за всяка дума означим  $q_\alpha = \delta^\star_\A(s,\alpha)$, то
  $\alpha \sim_\A \beta$ точно тогава, когато $q_\alpha = q_\beta$. Заключаваме, че броят на класовете на еквивалентност
  на $\sim_\A$ е равен на броя на достижимите от $s$ състояния.
\item
  Релациите $\approx_\L$ и $\sim_\A$ са дясно-инвариантни, т.е. за всеки две думи $\alpha$ и $\beta$
  е изпълнено:
  \begin{align*}
    \alpha \sim_\A \beta  &\implies (\forall \gamma\in\Sigma^\star)[\alpha\gamma \sim_\A \beta\gamma],\\
    \alpha \approx_\L \beta & \implies (\forall \gamma\in\Sigma^\star)[\alpha\gamma \approx_\L \beta\gamma].
  \end{align*}
\end{itemize}

\begin{thm}
  \label{th:rel-finer}
  За всеки ДКА $\A = \FA$ е изпълнено:
  \[(\forall \alpha,\beta \in \Sigma^\star)[\alpha\sim_\A\beta \implies \alpha\approx_{\L(\A)}\beta].\]
  С други думи, 
  $[\alpha]_\A \subseteq [\alpha]_{\L(\A)}$, за всяка дума $\alpha \in \Sigma^\star$.
\end{thm}
\begin{proof}
%  \marginpar{стр. 95 от \cite{papadimitriou}}
  Да означим за всяка дума $\alpha$, $q_\alpha = \delta^\star_\A(s, \alpha)$.
  Лесно се съобразява, че за всеки две думи $\alpha$ и $\beta$ имаме 
  \begin{align*}
    \alpha \sim_\A \beta & \iff \delta^\star(s,\alpha) = \delta^\star(s,\beta) & (\text{по деф. на }\sim_\A)\\
    & \iff q_\alpha = q_\beta.
  \end{align*}
  Нека $\alpha \sim_\A \beta$. Ще проверим, че  $\alpha \approx_{\L(\A)} \beta$.
  За произволно $\gamma \in \Sigma^\star$ имаме:
  \begin{align*}
    \alpha\gamma \in \L(\A) & \iff \delta^\star(s,\alpha\gamma)\in F & (\text{по деф. на }\L(\A))\\
    & \iff \delta^\star(\delta^\star(s,\alpha),\gamma) \in F & (\text{по деф. на }\delta^\star)\\
    & \iff \delta^\star(q_\alpha, \gamma) \in F & (q_\alpha = \delta^\star(s,\alpha))\\
    & \iff \delta^\star(q_\beta, \gamma) \in F & (q_\alpha = q_\beta, \text{ защото }\alpha \sim_\A \beta)\\
    & \iff \delta^\star(\delta^\star(s,\beta),\gamma) \in F & (q_\beta = \delta^\star(s,\beta))\\
    & \iff \delta^\star(s,\beta\gamma) \in F & (\text{по деф. на }\delta^\star)\\
    & \iff \beta\gamma \in \L(\A) & (\text{по деф. на }\L(\A)).
  \end{align*}
  Заключаваме, че 
  \[(\forall \alpha,\beta \in \Sigma^\star)[\alpha\sim_\A\beta \implies \alpha\approx_{\L(\A)}\beta].\]
\end{proof}

\begin{cor}
  \label{cor:approx-less-sim}
  За всеки тотален ДКА $\A$ е изпълнено, че
  \[\abs{\approx_{\L(\A)}} \leq \abs{\sim_\A},\]
  т.е. броят на класовете на еквивалентност на релацията $\approx_{\L(\A)}$
  не надвишава броя на класовете на еквивалентност на релацията $\sim_\A$.
\end{cor}
\begin{proof}
  Нека $A = \{[\alpha]_{\L(\A)} \mid \alpha\in\Sigma^\star\}$ и $B = \{[\alpha]_\A \mid \alpha\in\Sigma^\star\}$.
  Да разгледаме изображението $f:B\to A$, определено като $f([\alpha]_\A) = [\alpha]_{\L(\A)}$.
  \begin{itemize}
  \item 
    Първо ще проверим, че $f$ е {\bf функция}, т.е. трябва да проверим, че 
    \[(\forall\alpha,\beta\in\Sigma^\star)[\alpha \sim_\A \beta \implies f([\alpha]_\A) = f([\beta]_\A)].\]
    
    Да допуснем, че съществуват думи $\alpha$ и $\beta$, такива че
    $[\alpha]_{\A} = [\beta]_{\A}$, но $f([\alpha]_{\A}) = [\alpha]_{\L(\A)} \neq [\beta]_{\L(\A)} = f([\beta]_{\A})$.
    Понеже $\sim_\A$ релация на еквивалентност, от $[\alpha]_{\L(\A)} \neq [\beta]_{\L(\A)}$
    следва, че $[\alpha]_{\L(\A)} \cap [\beta]_{\L(\A)} = \emptyset$.
    От \Th{rel-finer} следва веднага, че това е невъзможно, защото
    \[\emptyset \neq [\alpha]_\A = [\beta]_\A \subseteq [\alpha]_{\L(\A)} \cap [\beta]_{\L(\A)}.\]
  \item
    \marginpar{$(\forall a\in A)(\exists b\in B)(f(b) = a)$}
    Очевидно е, че $f$ е {\bf сюрекция}, защото на всеки клас $[\alpha]_{\L(\A)}$ съответства класа $[\alpha]_\A$.
  \item
    \marginpar{Защо?\\ \writedown Обяснете!}
    От това, че $f:B\to A$ е сюрективна функция следва, че $\abs{A} \leq \abs{B}$.
  \end{itemize}
\end{proof}

\begin{cor}
  \label{cor:upper-bound}
  Нека $L$ е произволен регулярен език $L$.  
  Всеки тотален ДКА $\A$, който разпознава $L$ има свойството
  \[\abs{Q} \geq \abs{\approx_L},\]
  т.е. броят на класовете на еквивалентност на релацията $\approx_L$
  не надвишава броя на състоянията на автомата.
\end{cor}
\begin{proof}
  Да изберем $\A$, който разпознава $L$, бъде такъв, че да {\em няма недостижими състояния}.
  Тъй като всяко достижимо състояние определя клас на еквивалентност относно $\sim_\A$,
  то получаваме, че $\abs{Q} = \abs{\sim_\A}$.
  Комбинирайки със \Cor{approx-less-sim},
  \[\abs{Q} = \abs{\sim_\A} \geq \abs{\approx_L}.\]
\end{proof}
Така получаваме {\em долна граница} за броя на състоянията в тотален автомат разпознаващ езика $L$.
Този брой е не по-малък от броя на класовете на еквивалентност на $\approx_L$.


\subsection{Теорема за съществуване на минимален автомат}

\index{минимален автомат}
\begin{dfn}
  Нека $\A$ а тотален ДКА, за който $L = \L(\A)$.
  Казваме, че $\A$ е {\bf минимален} за езика $L$, ако $\abs{Q_\A} = \abs{\approx_L}$.
\end{dfn}

% Да приемем, че сме фиксирали азбуката $\Sigma$.
\begin{thm}[Майхил-Нероуд]
  \label{th:myhill-nerode}
  \index{Майхил-Нероуд!теорема}
  % \index{Майхил}
  % \index{Нероуд}
  \marginpar{на англ. Myhill-Nerode}
  Нека $L\subseteq \Sigma^\star$ е регулярен език.
  Тогава съществува ДКА $\A = \FA$, който разпознава $L$,
  с точно толкова състояния, колкото са класовете на еквивалентност на релацията $\approx_L$,
  т.е. $\abs{Q} = \abs{\approx_L}$.
\end{thm}
\begin{proof}
%  \marginpar{стр. 96 от \cite{papadimitriou}}
  Да фиксираме регулярния език $L$.
  Ще дефинираме тотален ДКА $\A = \FA$, разпознаващ $L$, като:
  \begin{itemize}
  \item
    $Q = \{[\alpha]_L\mid \alpha\in \Sigma^\star\}$;
  \item
    $s = [\varepsilon]_L$;
  \item
    $F = \{[\alpha]_L\mid \alpha\in L\} = \{[\alpha]_L \mid [\alpha]_L \cap L \neq \emptyset\}$;
  \item
    Определяме изображението $\delta$ като 
    за всяка буква $x \in \Sigma$ и всяко състояние $[\alpha]_L\in Q$, 
    \[\delta([\alpha]_L,x) = [\alpha x]_L.\]
  \end{itemize}
  
  Първо, трябва да се уверим, че множеството от състояния $Q$ е крайно, т.е.
  релацията $\approx_\L$ има крайно много класове на еквивалентност.
  И така, тъй като $\L$ е регулярен език, то той се разпознава от някой тотален ДКА $\A'$.
  От \Cor{upper-bound} имаме, че $\abs{Q^{\A'}} \geq \abs{\approx_L}$.
  Понеже $Q^{\A'}$ е крайно множество, то $\approx_L$ има крайно много класове и 
  следователно $Q$ също е крайно множество.

  Второ, трябва да се уверим, че изображението $\delta$ задава функция, т.е. 
  да проверим, че за всеки две думи $\alpha$, $\beta$ и всяка буква $x$,
  \[[\alpha]_L = [\beta]_L \implies \delta([\alpha]_L,x) = \delta([\beta]_L,x).\]
  Но това се вижда веднага, защото от определението на релацията $\approx_L$ следва, че
  ако $\alpha \approx_L \beta$, то за всяка буква $x$, $\alpha x \approx_L \beta x$,
  т.е. $[\alpha x]_L = [\beta x]_L$ и 
  \begin{align*}
    [\alpha]_L = [\beta]_L & \implies [\alpha x]_L = [\beta x]_L & (\text{свойство на }\approx_L)\\
    & \implies \delta([\alpha]_L,x) = [\alpha x]_L = [\beta x]_L = \delta([\beta]_L,x) & (\text{деф. на }\delta)
  \end{align*}
  
  Така вече сме показали, че $\A$ е коректно зададен тотален ДКА.
  Остава да покажем, че $\A$ разпознава езика $L$, т.е. $\L(\A) = L$.
  За целта, първо ще докажем едно помощно твърдение.
  \begin{prop}
    За всеки две думи $\alpha$ и $\beta$,
    $\delta^\star([\alpha]_L,\beta) = [\alpha\beta]_L$.
  \end{prop}
  \begin{proof}
    Ще докажем това свойство с индукция по дължината на $\beta$.
    \begin{itemize}
    \item
      За $\beta = \varepsilon$ свойството следва директно от дефиницията на $\delta^\star$ като рефлексивно и транзитивно затваряне на $\delta$,
      защото $\delta^\star([\alpha]_L,\varepsilon) = [\alpha]_L$.
    \item
      Нека $\abs{\beta} = n+1$ и да приемем, че сме доказали твърдението за думи с дължина $n$.
      Тогава $\beta = \gamma a$, където $\abs{\gamma} = n$. Свойството следва от следните равенства:
      \begin{align*}
        \delta^\star([\alpha]_L, \gamma a) & = \delta(\delta^\star([\alpha]_L,\gamma),a) & (\text{деф. на }\delta^\star)\\
                                          & = \delta([\alpha\gamma]_L,a) & (\text{от {\bf И.П.} за }\gamma)\\
                                          & = [\alpha\gamma a]_L & (\text{от деф. на }\delta)\\
                                          & = [\alpha\beta]_L & (\beta = \gamma a).
      \end{align*}
    \end{itemize}
  \end{proof}
  \noindent За да се убедим, че $L = \L(\A)$ е достатъчно да проследим еквивалентностите:
  \begin{align*}
    \alpha\in \L(\A) & \iff \delta^\star(s,\alpha) \in F & (\text{от деф. на }\L(\A))\\
                     & \iff \delta^\star([\varepsilon]_L,\alpha) \in F & (\text{по деф. }s = [\varepsilon]_L)\\
                     & \iff \delta^\star([\varepsilon]_L,\alpha) = [\alpha]_L\ \&\ \alpha\in L & (\text{от деф. на }F)\\
                     & \iff \alpha \in L & (\text{от последното твърдение}).
  \end{align*}
\end{proof}

\begin{dfn}
  \index{изоморфизъм}
  Нека $\A_1 = \FAn{1}$ и $\A_2 = \FAn{2}$.
  Казваме, че $\A_1$ и $\A_2$ са {\bf изоморфни}, което означаваме с $\A_1 \cong \A_2$, ако
  съществува биекция $f: Q_1\to Q_2$, за която:
  \begin{itemize}
  \item
    $f(s_1) = s_2$;
  \item
    $f[F_1] = \{f(q)\mid q\in F_1\} = F_2$;
  \item
    $(\forall a\in\Sigma)(\forall q\in Q_1)[f(\delta_1(q,a)) = \delta_2(f(q),a)]$.
  \end{itemize}
  Ще казваме, че $f$ задава изоморфизъм на $\A_1$ върху $\A_2$.
\end{dfn}

Това означава, че два автомата $\A_1$ и $\A_2$ са изоморфни, ако можем да получим $\A_2$
като преименуваме състоянията на $\A_1$.

\begin{cor}
  Нека е даден регулярния език $L$.
  Всички минимални автомати за $L$ са изоморфни на $\A_0$, автомата построен в теоремата на Нерод-Майхил.
\end{cor}
\begin{proof}
  Нека $\A = \FA$ е произволен тотален автомат, за който $\L(\A) = L$ и $\abs{Q} = \abs{\approx_L}$.
  Съобразете, че $\A$ е {\em свързан}, т.е. всяко състояние на $\A$ е достижимо от началното.
  Искаме да докажем, че $\A \cong \A_0$.
  Понеже $\A$ е свързан, за всяко състояние $q$ можем да намерим дума $\omega_q$,
  за която $\delta^\star(s,\omega_q) = q$.
  Да дефинираме изображението $f:Q\to [\approx_L]$ като $f(q) = [\omega_q]_L$.
  Ще докажем, че
  $f$ задава изоморфизъм на $\A$ върху $\A_0$. 
  \begin{itemize}
  \item
    Първо да съобразим, че ако $\delta^\star_\A(s,\alpha) = q$, то $[\omega_q]_L = [\alpha]_L$.
    Понеже $\delta^\star_\A(s,\alpha) = q = \delta^\star_\A(s,\omega_q)$, то $\omega_q \sim_\A \alpha$.
    От \Th{rel-finer} имаме, че
    \[\omega_q \sim_\A \alpha \implies \omega_q \approx_L \alpha.\]
    Това означава, $[\omega_q]_L = [\alpha]_L$ и следователно $f$ е определена коректно, т.е. $f$ е {\bf функция}.
  \item
    Ще проверим, че $f$ е {\bf инективна}, т.е.
    \[(\forall q_1,q_2 \in Q)[q_1\neq q_2 \implies f(q_1) \neq f(q_2)].\]
    Да допуснем, че има състояния $q_1 \neq q_2$, за които 
    \[f(q_1) = [\omega_{q_1}]_L = [\omega_{q_2}]_L = f(q_2).\]
    Тогава $\omega_{q_1} \not\sim_\A \omega_{q_2}$ и $\omega_{q_1} \approx_L \omega_{q_2}$.
    \marginpar{\writedown Обяснете!}
    Но тогава от \Cor{upper-bound} получаваме, че $\abs{\sim_\A} > \abs{\approx_L}$,
    което противоречи с минималността на $\A$.
  \item
    За да бъде $f$ {\bf сюрективна} трябва за всеки клас $[\beta]_L$ да съществува състояние $q$, за което $f(q) = [\beta]_L$.
    Понеже $\A$ е свързан, съществува състояние $q$, за което $\delta^\star_\A(s,\beta) = q$.
    Вече се убедихме, че в този случай $\beta \approx_L \omega_q$, защото $\beta \sim_\A \omega_q$.
    Тогава $f(q) = [\omega_q]_L = [\beta]_L$.
  \item
    За последно оставихме проверката, че $f$ наистина е {\bf изоморфизъм}:
    \begin{align*}
      f(\delta_\A(q,a)) & = f(\delta_\A(\delta^\star_\A(s,\omega_q),a)) & (\text{от избора на }\omega_q)\\
      & = f(\delta^\star_\A(s,\omega_qa)) & (\text{от деф. на }\delta^\star_\A)\\
      & = [\omega_qa]_L & (\text{от деф. на }f)\\
      & = \delta^\star_{\A_0}([\varepsilon]_L, \omega_qa) & (\text{от деф. на }\A_0)\\ 
      & = \delta_{\A_0}(\delta^\star_{\A_0}([\varepsilon]_L, \omega_q),a) & (\text{от деф. на }\delta^\star_{\A_0})\\
      & = \delta_{\A_0}([\omega_q]_L, a) & (\text{свойство на }\delta^\star_{\A_0})\\
      & = \delta_{\A_0}(f(q), a) & ( f(q) = [\omega_q]_L).
    \end{align*}
  \end{itemize}
\end{proof}

\subsection{Алгоритъм за строене на минимален автомат}
\begin{itemize}
\item
  Да фиксираме произволен тотален ДКА $\A = \FA$.
\item
  За състояние $p$ в автомата $\A$, да означим с $\L_\A(p)$ езикът, който се разпознава от автомата $\A$,
  ако приемем, че $p$ е началното състояние на автомата, т.е.
  \[\L_\A(p) = \{\omega \in \Sigma^\star \mid \delta^\star(p,\omega) \in F\}.\]
  В частност, $L = \L_\A(s)$.
\item
  Сега дефинираме следната релация между състояния на автомата $\A$:
  \[p \equiv_\A q\ \dff\ \L_\A(p) = \L_\A(q).\]
  Това означава, че $p \equiv_\A q$ точно тогава, когато
  \[(\forall \omega\in \Sigma^\star)[\delta^\star(p,\omega) \in F\ \iff\ \delta^\star(q,\omega) \in F].\]
\item
  Релацията $\equiv_\A$ между състояния на автомата $\A$ е релация на еквивалентност. 
\item
  Нека $q_\alpha$ е състоянието, което съответства на думата $\alpha$ в $\A$, т.е.
  $\delta^\star_\A(s,\alpha) = q_\alpha$. Тогава 
  \[\L_\A(q_\alpha) = \alpha^{-1}\L(\A).\]
  Оттук получаваме, че 
  \begin{align*}
    q_\alpha \equiv_\A q_\beta & \iff \L_\A(q_\alpha) = \L_\A(q_\beta)\\
    & \iff \alpha^{-1}\L(\A) = \beta^{-1}\L(\A)\\
    & \iff \alpha \sim_{\L(\A)} \beta.
  \end{align*}
  % \[q_\alpha \equiv_\A q_\beta\ \iff\ \alpha\approx_{\L(\A)} \beta.\]
  Това означава, че ако в $\A$ няма недостижими състояния от началното състояние $s$, то $\abs{\equiv_\A} = \abs{\approx_{\L(\A)}}$.
\end{itemize}

При даден език $L$ и тотален ДКА $\A = \FA$, който го разпознава, нашата цел е да построим нов ДКА $\A_0$,
който има толкова състояния колкото са класовете на еквивалентност на релацията $\approx_\L$.
Това ще направим като ``слеем'' състоянията на $\A$, които са еквивалентни относно релацията $\equiv_\A$.
Това означава, че всяко състояние на $\A_0$ ще отговаря на един клас на еквивалентност на релацията $\equiv_\A$.
Проблемът с намирането на класовете на еквивалентност на релацията $\equiv_\A$ е кванторът $\forall \gamma \in \Sigma^\star$
в нейната дефиницията, защото $\Sigma^\star$ е безкрайно множество от думи.

Да фиксираме автомата $\A$ и $L = \L(\A)$.
Да означим 
\[\L^n_\A(p) \df \{\omega \in \Sigma^\star \mid \abs{\omega} \leq n\ \&\ \delta^\star(p,\omega) \in F\}.\]
Според тази дефиниция, $L = \bigcup_{n\geq 0} \A_n(s)$.

За всяко естествено число $n$, дефинираме бинарните релации върху $Q$:
\[p \equiv_n q \dff \L^n_\A(p) = \L^n_\A(q).\]

% Алгоритъмът представлява намирането на релации $\equiv_n$, където
% \[p\equiv_n q \iff (\forall\gamma\in\Sigma^\star)[\abs{\gamma}\leq n\ \rightarrow\ (\delta^\star(p,\gamma) \in F\ \iff\ \delta^\star(q,\gamma) \in F)].\]
Релациите $\equiv_n$ представляват апроксимации на релацията $\equiv_\A$.
Обърнете внимание, че за всяко $n$, $\equiv_n$ е {\em по-груба} релация от $\equiv_{n+1}$, 
която на свой ред е по-груба от $\equiv_\A$.
Алгоритъмът строи $\equiv_n$ докато не срещнем $n$, за което $\equiv_n\ =\ \equiv_{n+1}$.
Тъй като броят на класовете на еквивалентност на $\equiv_\A$ е краен ($\leq \abs{Q}$), то 
със сигурност ще намерим такова $n$, за което $\equiv_n\ =\ \equiv_{n+1}$.
Тогава заключаваме, че $\equiv_\A\ =\ \equiv_n$.

Понеже единствената дума с дължина $0$ e $\varepsilon$ и по определение $\delta^\star(p,\varepsilon) = p$, 
лесно се съобразява, че $\equiv_0$ има два класа на еквивалентност.
Единият е $F$, а другият е $Q\setminus F$.

\begin{prop}
  За всеки две състояния $p,q \in Q$, и всяко $n$, $p \equiv_{n+1} q$ точно тогава, когато
  \begin{enumerate}[a)]
  \item
    $p \equiv_{n} q$ и
  \item
    $(\forall a \in \Sigma)[\delta(q,a) \equiv_{n} \delta(p,a)]$.
  \end{enumerate}
\end{prop}
\begin{proof}
  \marginpar{\cite[стр. 99]{papadimitriou}}
  \begin{align*}
    p \equiv_{n+1} q & \iff \L^{n+1}_\A(p) = \L^{n+1}_\A(q)\\
    & \iff \L^n_\A(p) = \L^n_\A(q)\ \&\ (\forall a \in \Sigma)[\L^n_\A(\delta(p,a)) = \L^n_\A(\delta(q,a))]\\
    & \iff p \equiv_n q\ \&\ (\forall a \in \Sigma)[\delta(p,a) \equiv_n \delta(q,a)].
  \end{align*}
\end{proof}

Нека е даден автомата $A = \FA$.
След като сме намерили релацията $\equiv_\A$ за $\A$, 
строим автомата $\A' = (Q',\Sigma,s',\delta',F')$, където:
\begin{itemize}
\item
  $Q' = \{[q]_{\equiv_\A} \mid q\in Q\}$;
\item
  $s' = [s]_{\equiv_\A}$;
\item
  $\delta'([q]_{\equiv_\A}, a) = [\delta(q,a)]_{\equiv_\A}$;
\item
  $F' = \{[q]_{\equiv_\A}\mid F\cap [q]_{\equiv_\A} \neq \emptyset\}$;
\end{itemize}

От всичко казано дотук знаем, че $\A'$ е минимален автомат разпознаващ езика $\L(\A)$.

\begin{example}
  Да разгледаме следния краен детерминиран автомат $\A$.
  \begin{figure}[H]
    \begin{subfigure}[b]{.4\textwidth}
      \begin{tikzpicture}[->,>=stealth,thick,node distance=55pt]
        \tikzstyle{every state}=[circle,minimum size=20pt,auto]
        
        \node[initial above, state]   (0) {$0$};
        \node[state]            (1) [above right of=0]{$1$};
        \node[state]            (2) [below right of=0]{$2$};
        \node[state,accepting]  (3) [right of=1]{$3$};
        \node[state,accepting]  (4) [right of=2]{$4$};
        \node[state,accepting]  (5) [below right of=3]{$5$};
        
        
        \path 
        (0) edge  node [above] {$a$}   (1)
        (0) edge  node [below] {$b$}   (2)
        (1) edge node [above] {$a$}    (3)
        (1) edge [bend left=15] node [below] {$b$}    (4)
        (2) edge [bend left=15] node [left] {$b$}    (3)
        (2) edge node [below] {$a$}   (4)
        (4) edge  node [below] {$a,b$} (5)
        (3) edge  node [left] {$a,b$}  (5)
        (5) edge [loop above]   node [above] {$a,b$}  (5);
      \end{tikzpicture}
      \caption{Ще построим минимален автомат разпознаващ $\L(\A)$}
    \end{subfigure}
    \qquad
    \qquad
    \begin{subfigure}[b]{0.5\textwidth}
      \begin{tikzpicture}[->,>=stealth,thick,node distance=45pt]
        \tikzstyle{every state}=[circle,minimum size=20pt,auto,scale=.9]
        
        \node[initial above, state]   (0) {$B_0$};
        \node[state]            (1) [right of=0]{$B_1$};
        \node[state,accepting]  (2) [right of=1]{$B_2$};
        
        \path 
        (0) edge [bend left=15] node [above] {$a,b$}   (1)
        (1) edge [bend left=15] node [above] {$a,b$}   (2)
        (2) edge [loop above] node [above] {$a,b$}   (2);
      \end{tikzpicture}
      \caption{Получаваме следния минимален автомат $\A_0$, $\L(\A_0) = \L(\A)$}
      \label{sub:min1}
    \end{subfigure}
  \end{figure}
  \marginpar{Съобразете, че $\L(\A) = \{\alpha \in \{a,b\}^\star \mid \abs{\alpha} \geq 2\}$.}

Ще приложим алгоритъма за минимизация за да получим минималния автомат за езика $L$.
За всяко $n = 0,1,2,\dots$, ще намерим класовете на еквивалентност на $\equiv_n$,
докато не намерим $n$, за което $\equiv_n\ =\ \equiv_{n+1}$.

\begin{itemize}
\item 
  Класовете на еквивалентност на $\equiv_0$ са два.
  Те са $A_0 = Q\setminus F = \{0,1,2\}$ и $A_1 = F = \{3,4,5\}$.
\item
  Сега да видим дали можем да разбием някои от класовете на еквивалентност на $\equiv_0$.
  
  \begin{tabular}{|c|c|c|c|c|c|c|}
    \hline
    $Q$ & $0$ & $1$ & $2$ & $3^\star$ & $4^\star$ & $5^\star$ \\
    \hline
    \hline
    $\equiv_0$ & $A_0$ & $A_0$ & $A_0$ & $A_1$ & $A_1$ & $A_1$\\
    \hline
    $a$ & $A_0$& $A_1$ & $A_1$ & $A_1$ & $A_1$ & $A_1$\\
    \hline
    $b$ & $A_0$& $A_1$ & $A_1$ & $A_1$ & $A_1$ & $A_1$\\
    \hline
  \end{tabular}

  Виждаме, че $0 \not\equiv_1 1$ и $1 \equiv_1 2$.
  Класовете на еквивалентност на $\equiv_1$ са 
  $B_0 = \{0\}$, $B_1 = \{1,2\}$, $B_2 = \{3,4,5\}$.
\item
  Сега да видим дали можем да разбием някои от класовете на еквивалентност на $\equiv_1$.
  
  \begin{tabular}{|c|c|c|c|c|c|c|}
    \hline
    $Q$ & $0$ & $1$ & $2$ & $3^\star$ & $4^\star$ & $5^\star$ \\
    \hline
    \hline
    $\equiv_1$ & $B_0$ & $B_1$ & $B_1$ & $B_2$ & $B_2$ & $B_2$\\
    \hline
    $a$ & $B_1$ & $B_2$ & $B_2$ & $B_2$ & $B_2$ & $B_2$\\
    \hline
    $b$ & $B_1$ & $B_2$ & $B_2$ & $B_2$ & $B_2$ & $B_2$\\
    \hline
  \end{tabular}

  Виждаме, че $\equiv_1\ =\ \equiv_2$.
  \marginpar{Получаваме, че $\equiv_\A\ =\ \equiv_1$}
  Следователно, минималният автомат има три състояния.
  Той е изобразен на Фигура \ref{sub:min1}.  
  Минималният автомат може да се представи и таблично:
  
  \begin{tabular}{|c|c|c|c|c|c|c|}
    % \hline
    % $Q$ & $0$ & $1$ & $2$ & $3^\star$ & $4^\star$ & $5^\star$ \\
    % \hline
    \hline
    $\delta$ & $B_0$ & $B_1$ & $B_2$ \\
    \hline
    $a$ & $B_1$ & $B_2$ & $B_2$ \\
    \hline
    $b$ & $B_1$ & $B_2$ & $B_2$ \\
    \hline
  \end{tabular}
\end{itemize}
\end{example}

\begin{example}
  Да разгледаме следния краен детерминиран автомат $\A$.
  \begin{figure}[H]
    % \begin{center}
    \begin{subfigure}[b]{0.4\textwidth}
      \begin{tikzpicture}[->,>=stealth,thick,node distance=55pt]
        \tikzstyle{every state}=[circle,minimum size=20pt,auto]
        
        \node[initial above, state]   (0) {$0$};
        \node[state,accepting]        (1) [above right of=0]{$1$};
        \node[state,accepting]        (2) [below right of=0]{$2$};
        \node[state]                  (3) [right of=1]{$3$};
        \node[state]                  (4) [right of=2]{$4$};
        \node[state,accepting]        (5) [below right of=3]{$5$};
        
        \path 
        (0) edge node [below] {$a$}   (1)
            edge node [below] {$b$}   (2)
        (1) edge node [above] {$a$}    (3)
            edge [bend left=15] node [below] {$b$}    (4)
        (2) edge [bend left=15] node [left] {$b$}    (3)
            edge node [below] {$a$}   (4)
        (4) edge node [below] {$a,b$} (5)
        (3) edge node [left] {$a,b$}  (5)
        (5) edge [loop above]   node [above] {$a,b$}  (5);
      \end{tikzpicture}
      \caption{Ще построим минимален автомат разпознаващ $\L(\A)$}
    \end{subfigure}
    \qquad
    \qquad
    \begin{subfigure}[b]{0.4\textwidth}
      \begin{tikzpicture}[->,>=stealth,thick,node distance=45pt]
        \tikzstyle{every state}=[circle,minimum size=20pt,auto,scale=.9]
        
        \node[initial above, state]   (0) {$C_0$};
        \node[state,accepting]  (1) [right of=0]{$C_1$};
        \node[state]            (2) [right of=1]{$C_2$};
        \node[state,accepting]  (3) [right of=2]{$C_3$};
                
        \path 
        (0) edge [bend left=15] node [above] {$a,b$}   (1)
        (1) edge [bend left=15] node [above] {$a,b$}   (2)
        (2) edge [bend left=15] node [above] {$a,b$}   (3)
        (3) edge [loop above]   node [above] {$a,b$}   (3);
      \end{tikzpicture}
      \caption{Получаваме следния минимален автомат $\A_0$, $\L(\A_0) = \L(\A)$}
      \label{sub:min2}
    \end{subfigure}
  \end{figure}

  \marginpar{Съобразете, че $\L(\A) = \{a,b\} \cup \{\alpha \in \{a,b\}^\star \mid \abs{\alpha} \geq 3\}$.}
  
  Отново следваме същата процедура за минимизация.
  Ще намерим класовете на еквивалентност на $\equiv_n$,
  докато не намерим $n$, за което $\equiv_n\ =\ \equiv_{n+1}$.
  \begin{itemize}
  \item
    Класовете на екиваленост на $\equiv_0$ са 
    $A_0 = Q\setminus F = \{0,3,4\}$ и $A_1 = F = \{1,2,5\}$.
  \item
    Разбиваме класовете на еквивалентност на $\equiv_0$.
    
    \begin{tabular}{|c|c|c|c|c|c|c|}
      \hline
      $Q$ & 0 & $1^\star$ & $2^\star$ & 3 & 4 & $5^\star$ \\
      \hline
      \hline
      $\equiv_0$ & $A_0$ & $A_1$ & $A_1$ & $A_0$ & $A_0$ & $A_1$\\
      \hline
      $a$ & $A_1$& $A_0$ & $A_0$ & $A_1$ & $A_1$ & $A_1$\\
      \hline
      $b$ & $A_1$& $A_0$ & $A_0$ & $A_1$ & $A_1$ & $A_1$\\
      \hline
    \end{tabular}
    
    Виждаме, че $1 \not\equiv_1 5$ и $1 \equiv_0 5$.
    Следователно, $\equiv_0\ \neq\ \equiv_1$.
    Класовете на еквивалентност на $\equiv_1$ са 
    $B_0 = \{0,3,4\}$, $B_1 = \{1,2\}$, $B_2 = \{5\}$.
  \item
    Сега се опитваме да разбием класовете на еквивалентност на $\equiv_1$.

    \begin{tabular}{|c|c|c|c|c|c|c|}
      \hline
      $Q$ & 0 & $1^\star$ & $2^\star$ & 3 & 4 & $5^\star$ \\
      \hline
      \hline
      $\equiv_1$ & $B_0$ & $B_1$ & $B_1$ & $B_0$ & $B_0$ & $B_2$\\
      \hline
      $a$ & $B_1$ & $B_0$ & $B_0$ & $B_2$ & $B_2$ & $B_2$\\
      \hline
      $b$ & $B_1$ & $B_0$ & $B_0$ & $B_2$ & $B_2$ & $B_2$\\
      \hline
    \end{tabular}
    
    Имаме, че $0 \equiv_1 3$, но $0 \not\equiv_2 3$. Следователно $\equiv_1\ \neq\ \equiv_2$.
    Класовете на еквивалентност на $\equiv_2$ са 
    $C_0 = \{0\}$, $C_1 = \{1,2\}$, $C_2 = \{3,4\}$, $C_3 = \{5\}$.
  \item
    Отново опитваме да разбием класовете на $\equiv_2$.

      \begin{tabular}{|c|c|c|c|c|c|c|}
        \hline
        $Q$ & 0 & $1^\star$ & $2^\star$ & 3 & 4 & $5^\star$ \\
        \hline
        \hline
        $\equiv_2$ & $C_0$ & $C_1$ & $C_1$ & $C_2$ & $C_2$ & $C_3$\\
        \hline
        $a$ & $C_1$ & $C_2$ & $C_2$ & $C_3$ & $C_3$ & $C_3$\\
        \hline
        $b$ & $C_1$ & $C_2$ & $C_2$ & $C_3$ & $C_3$ & $C_3$\\
        \hline
      \end{tabular}
      
      Виждаме, че не можем да разбием $C_1$ или $C_2$.
      \marginpar{Получаваме, че $\equiv_\A\ =\ \equiv_2$}
      Следователно, $\equiv_2\ =\ \equiv_3$ и минималният автомат разпознаващ езика $L$
      има четири състояния. Вижте Фигура \ref{sub:min2} за преходите на минималния автомат.
      Минималният автомат може да се представи и таблично:

      \begin{tabular}{|c|c|c|c|c|}
        \hline
        $\delta$ & $C_0$ & $C_1$ & $C_2$ & $C_3$ \\
        \hline
        $a$ & $C_1$ & $C_2$ & $C_3$ & $C_3$ \\
        \hline
        $b$ & $C_1$ & $C_2$ & $C_3$ & $C_3$ \\
        \hline
      \end{tabular}
      
  \end{itemize}
\end{example}

\section{Регулярни граматики}
\index{граматика!неограничена}

{\bf Неограничена граматика} e четворка от вида
\[G = (V, \Sigma, R, S),\]
където
\begin{itemize}
\item
  \marginpar{Променливите се наричат също нетерминали}
  $V$ е крайно множество от {\em променливи};
\item
  \marginpar{Буквите се наричат също терминали.}
  $\Sigma$ е крайно множество от {\em букви}, $\Sigma \cap V = \emptyset$;
\item
  \marginpar{В \cite{hopcroft1} правилата се наричат {\em productions}}
  $R \subseteq (V\cup\Sigma)^\star \times (V \cup \Sigma)^\star$ е крайно множество от {\em правила}.
  Обикновено правилата $(\alpha, \beta) \in R$ ще означаваме като 
  $\alpha \to_G \beta$, където $\alpha, \beta \in (V \cup \Sigma)^\star$;
\item
  $S \in V$ е началната променлива. 
\end{itemize}

Казваме, че имаме {\bf извод} $\omega \to_G \omega'$, ако $\omega = \alpha\beta\gamma \in (V\cup\Sigma)^\star$,
$\omega' = \alpha\beta'\gamma \in (V\cup\Sigma)^\star$ и имаме правило $\beta \to \beta'$ в граматиката $G$.
Нека $\to^\star_G$ е рефлексивното и транзитивно затваряне на релацията $\to_G$, т.е.
\begin{align*}
  & \alpha \to^\star_G \alpha\\
  & \alpha \to^\star_G \alpha'\ \&\ \alpha' \to_G \alpha'' \implies \alpha \to^\star_G \alpha''.
\end{align*}

Езикът, който се поражда от граматиката $G$ е
\[\L(G) = \{\omega \in \Sigma^\star \mid S \to^\star_G \omega\}.\]

Граматиките се разделят на няколко вида в зависимост от това какви {\em ограничения} налагаме върху правилата $R$.
В следващите няколко глави ще разгледаме различни ограничения. Сега ще разгледаме граматики с такъв вид правила,
които пораждат точно регулярните (или еквивалентно автоматни) езици.

\index{граматика!регулярна}
Граматиката $G = (V, \Sigma, R, S)$ се нарича {\bf регулярна граматика},
ако правилата $R$ са от вида 
\begin{align*}
  & A \to \varepsilon,\\
  & A \to a,\\
  & A \to aB,
\end{align*}
където $A, B \in V$ и $a \in \Sigma$.

\begin{prop}
  Нека $G$ е регулярна граматика и $L = \L(G)$.
  Съществува краен автомат $\A$, такъв че $L = \L(\A)$.
\end{prop}

\begin{prop}
  Нека $\A$ е краен автомат и $L = \L(\A)$.
  Съществува регулярна граматика $G$, такава че $L = \L(G)$.
\end{prop}




\section*{Библиография}

Основни източници в тази глава са:
\begin{itemize}
\item 
  глави 2 и 3 от \cite{hopcroft1}.
\item
  глави 2,3 и 4 от \cite{hopcroft2}.
\item
  Глава 1 от \cite{sipser1}.
\item
  глава 2 от \cite{papadimitriou}.
\item
  Първа част на \cite{kozen}. Въпросът за минимизация на автомат е разгледан подробно.
\end{itemize}


% \section{Въпроси}

% Вярно ли е, че:
% \begin{itemize}
%   % \item
% %   \marginpar{Не}
% %   езикът $\{a^nb^n\mid n \in \Nat \}$ е регулярен?
% % \item
% %   \marginpar{Не}
% %   езикът $\{a^nb^k\mid n > k\}$ е регулярен?
% % \item
% %   \marginpar{Не}
% %   езикът $\{a^{n^2}\mid n \in \Nat\}$ е регулярен?
% \item
%   \marginpar{Да}
%   за всеки два регулярни езика $R_1, R_2$, то $R_1 \setminus R_2$ е регулярен ?
% \item
%   \marginpar{Да}
%   за всеки краен език $F$ и всеки регулярен $R$, то $R\setminus F$ е регулярен ?
% \item
%   \marginpar{Да}
%   за всеки краен език $F$ и всеки рег. $R$, то $R\cup (\Sigma^\star \setminus F)$ е регулярен ?
% \item
%   \marginpar{Да}
%   съществува регулярен език $R$ и нерегулярен $K$, за които $R\cap K$ не е регулярен ?
% \item
%   \marginpar{Да}
%   съществува регулярен език $R$ и нерегулярен $K$, за които $R\setminus K$ не е регулярен ?
% \item
%   \marginpar{Не}
%   за всеки регулярен език $R$ и всеки $K \subseteq R$, то $R\setminus K$ е регулярен ?
% \item
%   \marginpar{Не}
%   Езикът $L = \{\omega \in \{a,b\}^\star \mid n_a(\omega) \text{ не дели }n_b(\omega)\}$ е регулярен?
% \item
%   \marginpar{Да}
%   съществува алгоритъм, който може да провери дали за даден регулярен израз $r$
%   е изпълнено, че $\abs{\L(r)} = 0$.
% \item
%   \marginpar{Да}
%   съществува алгоритъм, който може да провери дали за даден регулярен израз $r$
%   е изпълнено, че $\abs{\L(r)} < \infty$.
% \item
%   \marginpar{Да}
%   съществува алгоритъм, който може да провери дали за даден регулярен израз $r$
%   е изпълнено, че $\abs{\L(r)} = \infty$.
% \item
%   \marginpar{Да}
%   съществува алгоритъм, който може да провери дали за дадени регулярни изрази $r_1$ и $r_2$
%   е изпълнено, че $\L(r_1) = \L(r_2)$.
% \item
%   съществува алгоритъм, който може да провери дали за дадени регулярни изрази $r_1$ и $r_2$
%   е изпълнено, че $\L(r_1) \neq \L(r_2)$.
% \item
%   съществува алгоритъм, който може да провери дали за дадени регулярни изрази $r_1$ и $r_2$
%   е изпълнено, че $\L(r_1) \subseteq \L(r_2)$.
% \item
%   съществува алгоритъм, който може да провери дали за дадени регулярни изрази $r_1$ и $r_2$
%   е изпълнено, че $\L(r_1) \subsetneq \L(r_2)$.
% \item
%   съществува алгоритъм, който може да провери дали за дадени регулярни изрази $r_1$ и $r_2$
%   е изпълнено, че $\L(r_1) \cap \L(r_2) = \emptyset$.
% \item
%   съществува алгоритъм, който може да провери дали за дадени регулярни изрази $r_1$ и $r_2$
%   е изпълнено, че $\L(r_1) \cap \L(r_2) \neq \emptyset$.
% \item
%   съществува алгоритъм, който може да провери дали за дадени регулярни изрази $r_1$ и $r_2$
%   е изпълнено, че $\L(r_1) \cup \L(r_2) = \emptyset$.
% \item
%   съществува алгоритъм, който може да провери дали за дадени регулярни изрази $r_1$ и $r_2$
%   е изпълнено, че $\L(r_1) \cup \L(r_2) \neq \emptyset$.
% \item
%   съществува алгоритъм, който може да провери дали за дадени регулярни изрази $r_1$ и $r_2$
%   е изпълнено, че $\L(r_1) \setminus \L(r_2) = \emptyset$.
% \item
%   съществува алгоритъм, който може да провери дали за дадени регулярни изрази $r_1$ и $r_2$
%   е изпълнено, че $\L(r_1) \setminus \L(r_2) \neq \emptyset$.
% \end{itemize}

% \section{Домашна работа}

% \begin{itemize}
% \item
%   Вход - файл, в който е записан регулярен израз
% \item
%   Преобразуване на регулярния израз в обратен полски запис.
%   (\href{http://en.wikipedia.org/wiki/Shunting-yard_algorithm}{тук} 
%   добре е обяснено как става за произволни аритмечни изрази)
% \item
%   Строене на краен детерминиран автомат по регулярния израз.
% \item
%   Извеждане на автомата във формат за програмата \href{http://graphviz.org}{graphviz}.
%   (вижте \href{http://sundarpillay.blogspot.com/2012/02/graphviz-and-finite-automata-diagrams_05.html}{пример})
% \end{itemize}


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "EAI"
%%% End: 
