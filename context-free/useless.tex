\subsubsection*{Премахване на безполезните променливи}

Нека е дадена безконтекстната граматика $G = \CFG$.
\mynote{\cite[стр. 88]{hopcroft1}}
Една променлива $A$ се нарича {\bf полезна}, ако съществува извод от следния вид:
\[S \derive{\star}_G \alpha A \beta \derive{\star}_G \gamma,\]
където $\gamma \in \Sigma^\star$, а $\alpha,\beta \in (V \cup \Sigma)^\star$.
Това означава, че една променлива е полезна, ако участва в извода на някоя дума в езика на граматиката.
Една променлива се нарича {\bf безполезна}, ако не е полезна.
Целта ни е да получим еквивалентна граматика $G'$ без безполезни променливи.
Ще решим задачата като разгледаме две леми.

\begin{lemma}
  \label{lem:useless1}
  Нека е дадена безконтекстната граматика $G$ и $\L(G) \neq \emptyset$.
  Съществува алгоритъм, който намира граматика $G'$, за която
  $\L(G) = \L(G')$ и със свойството, че  за всяка променлива $A' \in V'$, съществува дума $\alpha \in \Sigma^\star$,
  за която $A' \to^\star_{G'} \alpha$.
\end{lemma}
\begin{hint}
  Целта ни е да намерим множеството $\texttt{Gen}$ от променливи, които генерират думи, т.е. търсим
  \[\texttt{Gen} \df \{A \in V \mid A \to^\star_G \alpha\ \&\ \alpha \in \Sigma^\star \}.\]
  За целта ще построим редица от множества $\texttt{Gen[n]}$ по следния начин:
  \mynote{Всяка итерация на алгоритъма отнема $\mathcal{O}(|G|)$ време. Следователно, изпълнението на целия алгоритъм отнема $\mathcal{O}(|G|^2)$ време.}
  \begin{itemize}
  \item 
    $\texttt{Gen[0]} \df \emptyset$;
  \item
    $\texttt{G[n+1]} \df \texttt{Gen[n]} \cup \{A\in V \mid A \to_G \alpha\ \&\ \alpha \in (\Sigma \cup \texttt{Gen[n]})^\star \}$.
  \item
    Спираме, когато стигнем до такова $n$, за което $\texttt{Gen[n]} = \texttt{G[n+1]}$. Лесно се съобразява, че
    $(\forall k \geq n)[\texttt{Gen[n]} = \texttt{Gen[k]}]$.
  \end{itemize}

  Трябва да докажем, че $\texttt{Gen} = \texttt{Gen[n]}$.
  Това ще направим като докажем, че
  \begin{align*}
    A \in \texttt{Gen[n]} \iff & \text{ съществува дърво на извод } P\text{, за което}\\
                               & \texttt{root}(P) = A\ \&\ \texttt{yield}(P) \in \Sigma^\star\ \&\ \texttt{height}(P) \leq n.
  \end{align*}
  Дефинираме $G'$ като $V' = V_n$ и правилата на $G'$ са само тези правила на $G$, в които участват променливи от $V_n$ и букви от $\Sigma$.
\end{hint}



{\scriptsize
  \begin{multicols}{2}
\begin{example}
  Да разгледаме следната граматика $G$:
  \begin{align*}
    & S \to AB\ |\ aA\\
    & A \to a\ |\ aAa\\
    & B \to SB\ |\ BC\\
    & C \to \varepsilon\ |\ cC.
  \end{align*}
  Първо да намерим променливите, от които се извеждат думи.
  \begin{itemize}
  \item
    $\texttt{Gen[0]} = \emptyset$
  \item 
    $\texttt{Gen[1]} = \{A, C\}$, защото $A \to a$ и $C \to \varepsilon$;
  \item
    $\texttt{Gen[2]} = \{A, C, S\}$, защото $S \to aA$;
  \item
    не можем да добавим $B$ към $\texttt{Gen[3]}$, следователно $\texttt{Gen[3]} = \texttt{Gen[2]}$.
  \end{itemize}
  Получаваме граматиката $G'$:
  \begin{align*}
    & S \to aA\\
    & A \to a\ |\ aAa\\
    & C \to \varepsilon\ |\ cC.
  \end{align*}
  Сега премахваме променливите и буквите, които не са достижими от началната промелива $S$. Така получаваме граматиката $G''$:
  \begin{align*}
    & S \to aA\\
    & A \to a\ |\ aAa.
  \end{align*}
\end{example}

\end{multicols}
}


\begin{framed}
  \begin{corollary}
    Съществува {\em полиномиален} алгоритъм, който определя за всяка безконтекстна граматика $G$ дали $\L(G) = \emptyset$.
  \end{corollary}  
\end{framed}
\begin{proof}
  Прилагаме алгоритъма от \Lemma{useless1}.
  Тогава $\L(G) = \emptyset$ точно тогава, когато $S \not\in V'$.  
\end{proof}

\begin{lemma}
  \label{lem:useless2}
  Съществува алгоритъм, който по дадена безконтекстна граматика $G = \CFG$, намира $G' = \pair{V',\Sigma',S,R'}$, $\L(G') = \L(G)$,
  със свойството, че за всяко $X \in V' \cup \Sigma'$ съществуват $\alpha, \beta \in (V'\cup\Sigma')^\star$,
  за които $S \to^\star \alpha X \beta$,
  т.е. всяка променлива или буква в $G'$ е достижима от началната променлива $S$.
\end{lemma}
\begin{hint}
  Нашата цел е да намерим множеството
  \[\texttt{Reach} \df \{X \in \Sigma \cup V \mid S \to^\star_G \alpha X \beta\text{, за някои }\alpha,\beta \in (\Sigma \cup V)^\star\}.\]
  Новата граматика $G'$ ще има букви $\Sigma' = \Sigma \cap \texttt{Reach}$ и променливи $V' = V \cap \texttt{Reach}$,
  като правилата на граматика $G'$ са същите като тези на $G$, но ограничени до $V'$ и $\Sigma'$.
  Лесно се доказава, че $\L(G) = \L(G')$.
  Остава да намерим множеството $\texttt{Reach}$.

  За целта ще започнем да строим мномножествата $\texttt{Reach[i]} \subseteq V \cup \Sigma$ по следния начин:
  \begin{itemize}
  \item
    $\texttt{Reach[0]} \df \{S\}$.
  \item
    \mynote{Всяка итерация отнема време $\mathcal{O}(|G|)$. Следователно, можем да намерим $G'$ за време $\mathcal{O}(|G|^2)$.}
    Нека приемем, че сме построили $\texttt{Reach[i]}$ и да положим $V_i = V \cap \texttt{Reach[i]}$.
    Тогава
    \[\texttt{Reach[i+1]} \df \{ X \in V \cup \Sigma \mid (\exists A \in V_i)[ A \to_G \alpha X \beta\text{, за някои }\alpha,\beta \in (V \cup \Sigma)^\star]\}.\]
  \item
    Докажете, че за всяко $i$,
    \[\texttt{Reach[i]} = \{X \in \Sigma \cup V \mid S \derive{\leq i}{G} \alpha X \beta\text{, за някои }\alpha,\beta \in (\Sigma \cup V)^\star\}.\]
  \item
    \mynote{Защо сме сигурни, че ще достигнем такава стъпка?}
    Спираме да строим тези множества, когато достигнем до стъпка $n$, за която
    \[\texttt{Reach[n]} = \texttt{Reach[n+1]}.\]
    Съобразете, че за това $n$ е изпълнено, че
    \[\texttt{Reach[n]} = \{X \in \Sigma \cup V \mid S \to^\star_G \alpha X \beta\text{, за някои }\alpha,\beta \in (\Sigma \cup V)^\star\}.\]
  % \item
  %   Новата граматика $G'$ ще има букви $\Sigma' = \Sigma \cap \texttt{Reach[n]}$ и променливи $V' = V \cap \texttt{Reach[n]}$,
  %   като правилата на граматика $G'$ са същите като тези на $G$, но ограничени до $V'$ и $\Sigma'$.
  %   Ясно е, че $\L(G') \subseteq \L(G)$.
  % \item
  %   Докажте, че $\L(G) \subseteq \L(G')$.
  \end{itemize}
  
  
  
  % \begin{align*}
  %   & V_n = \{A \in V \mid S \stackrel{\leq n}{\to}_G \alpha A \beta\text{, за някои }\alpha,\beta \in (\Sigma \cup V)^\star\}\\
  %   & \Sigma_n = \{a \in \Sigma \mid S \stackrel{\leq n}{\to}_G \alpha a \beta\text{, за някои }\alpha,\beta \in (\Sigma\cup V)^\star\}.
  % \end{align*}
  % \begin{itemize}
  % \item
  %   Ясно е, че $V_0 = \{S\}$ и $\Sigma_0 = \emptyset$.
  % \item
  %   \marginpar{Всяка итерация отнема време $\mathcal{O}(|G|)$. Следователно, можем да намерим $G'$ за време $\mathcal{O}(|G|^2)$.}
  %   Нека имаме $V_n$ и $\Sigma_n$. Тогава:
  %   \begin{align*}
  %     & V_{n+1} = \{A \in V \mid (\exists B \in V_n)[ B \to_G \alpha A \beta\text{, за някои }\alpha,\beta \in (\Sigma\cup V)^\star]\}\\
  %     & \Sigma_{n+1} = \{a \in \Sigma \mid (\exists B \in V_n)[ B \to_G \alpha a \beta\text{, за някои }\alpha,\beta \in (\Sigma\cup V)^\star]\}.
  %   \end{align*}
  % \item
  %   Спираме, когато намерим първото $n$, за което $V_n = V_{n+1}$ и $\Sigma_n = \Sigma_{n+1}$.
  %   Тогава $V' = V_n$ и $\Sigma' = \Sigma_n$.
  % \end{itemize}
\end{hint}

\begin{theorem}
  За всяка безконтекстна граматика $G$, за която $\L(G) \neq \emptyset$, съществува еквивалетнтна на нея безконтекстна граматика $G'$ без безполезни правила.
  Освен това, граматиката $G'$ може да се намери за полиномиално време.
\end{theorem}
\begin{hint}
  \mynote{\writedown Защо е важна последователността на прилагане? Алгоритъмът описан тук е квадратичен. Има и линеен такъв. Вижте \cite[стр. 296]{hopcroft2}}
  Прилагаме върху $G$ първо процедурата от \Lemma{useless1} и след това върху резултата прилагаме процедурата от \Lemma{useless2}.
\end{hint}

\begin{problem}
  Проверете дали $\L(G) = \emptyset$, където правилата на $G$ са:
  \begin{align*}
    & S \to AS\ |\ BC\\
    & A \to 0\ |\ BA\ |\ SB\\
    & B \to 1\ |\ BC\ |\ AB\\
    & C \to CB\ |\ SC\ |\ AS.
  \end{align*}
\end{problem}



%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../eai"
%%% End:
